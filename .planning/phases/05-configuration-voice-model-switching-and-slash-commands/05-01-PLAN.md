---
phase: 05-configuration-voice-model-switching-and-slash-commands
plan: "01"
type: execute
wave: 1
depends_on: []
files_modified:
  - agenttalk/config_loader.py
  - agenttalk/tts_worker.py
  - agenttalk/service.py
autonomous: true
requirements:
  - CFG-01
  - CFG-02
  - CFG-03
  - CMD-02
  - CMD-03

must_haves:
  truths:
    - "config_loader.py exports save_config(state) that atomically writes all 7 CFG-02 fields to %APPDATA%/AgentTalk/config.json via .json.tmp + Path.replace()"
    - "save_config() is thread-safe via a module-level _CONFIG_LOCK threading.Lock()"
    - "tts_worker.STATE dict has two new keys: 'model' (default 'kokoro') and 'piper_model_path' (default None)"
    - "service.py exposes POST /config that accepts a partial ConfigRequest body, updates matching STATE keys, calls save_config(STATE), and returns {status: ok, updated: [...]}"
    - "service.py exposes POST /stop that calls sd.stop() then schedules os._exit(0) in a daemon thread so the HTTP response is returned before the process exits"
    - "service.py main() loads ALL 7 CFG-02 keys from config.json into STATE at startup — not just cue paths"
    - "A curl POST to /config with {\"voice\": \"af_bella\"} returns 200 {status: ok} and STATE['voice'] becomes 'af_bella' immediately (CFG-03)"
    - "After POST /config, config.json on disk contains the updated value (CFG-01, CFG-02)"
  artifacts:
    - path: "agenttalk/config_loader.py"
      provides: "save_config(state) — atomic write of 7 settings fields to config.json; _CONFIG_LOCK guards concurrent writes"
      exports: ["load_config", "save_config"]
    - path: "agenttalk/tts_worker.py"
      provides: "STATE dict with 'model' and 'piper_model_path' keys added"
      contains: "piper_model_path"
    - path: "agenttalk/service.py"
      provides: "POST /config and POST /stop FastAPI endpoints; full 7-key config hydration at startup"
      contains: "/config"
  key_links:
    - from: "agenttalk/service.py"
      to: "agenttalk/config_loader.py"
      via: "from agenttalk.config_loader import load_config, save_config"
      pattern: "save_config"
    - from: "agenttalk/service.py"
      to: "agenttalk/tts_worker.py"
      via: "STATE dict updated by /config endpoint handler"
      pattern: "STATE\\[key\\]"
---

<objective>
Add config persistence (save_config), two new FastAPI control endpoints (/config, /stop), and extend STATE with engine-switching keys.

Purpose: This is the service-side foundation for all Phase 5 runtime control. Slash commands (Plan 05-03) and Piper engine switching (Plan 05-02) both depend on /config and save_config existing. config.json write support closes CFG-01/02/03.

Output: Modified config_loader.py (save_config added), modified tts_worker.py (model + piper_model_path STATE keys), modified service.py (/config + /stop endpoints, full 7-key config hydration at startup).
</objective>

<execution_context>
@C:/Users/omern/.claude/get-shit-done/workflows/execute-plan.md
@C:/Users/omern/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/05-configuration-voice-model-switching-and-slash-commands/05-RESEARCH.md

<interfaces>
<!-- Contracts from existing Phase 4 codebase. No codebase exploration needed. -->

From agenttalk/config_loader.py (current Phase 4 state):
```python
import json, logging, os, pathlib

def _config_path() -> pathlib.Path:
    appdata = os.environ.get("APPDATA", str(pathlib.Path.home()))
    return pathlib.Path(appdata) / "AgentTalk" / "config.json"

def load_config() -> dict:
    """Returns {} on missing/malformed file. Never raises."""
    ...
```

From agenttalk/tts_worker.py (current Phase 4 STATE):
```python
STATE: dict = {
    "volume": 1.0,
    "speed": 1.0,
    "voice": "af_heart",
    "muted": False,
    "speaking": False,
    "pre_cue_path": None,
    "post_cue_path": None,
}
```

From agenttalk/service.py (current Phase 4 startup config hydration — partial, only reads cue paths):
```python
_cfg = load_config()
if _cfg.get("pre_cue_path"):
    STATE["pre_cue_path"] = _cfg["pre_cue_path"]
if _cfg.get("post_cue_path"):
    STATE["post_cue_path"] = _cfg["post_cue_path"]
```

From agenttalk/service.py (existing imports):
```python
from agenttalk.tts_worker import TTS_QUEUE, STATE, start_tts_worker, _ducker
from agenttalk.config_loader import load_config
from pydantic import BaseModel
```

From 05-RESEARCH.md (Pattern 2 — /config endpoint):
```python
from pydantic import BaseModel
from typing import Optional

class ConfigRequest(BaseModel):
    voice: Optional[str] = None
    speed: Optional[float] = None
    volume: Optional[float] = None
    model: Optional[str] = None       # "kokoro" or "piper"
    muted: Optional[bool] = None
    pre_cue_path: Optional[str] = None
    post_cue_path: Optional[str] = None

@app.post("/config", status_code=200)
async def update_config(req: ConfigRequest):
    updates = req.model_dump(exclude_none=True)
    for key, value in updates.items():
        if key in STATE:
            STATE[key] = value
    save_config(STATE)
    return JSONResponse({"status": "ok", "updated": list(updates.keys())})
```

From 05-RESEARCH.md (Pattern 5 — /stop endpoint, connection-reset pitfall):
```python
@app.post("/stop", status_code=200)
async def stop_service():
    import sounddevice as sd
    sd.stop()
    os._exit(0)    # NOTE: terminates before HTTP response fully delivers
```

CRITICAL: os._exit(0) terminates the process before the HTTP response is fully sent.
curl exits with code 52 or 56 (connection reset). The slash command uses `|| true` to
treat this as success. To improve reliability, send a 200 first then exit in a short-delay
thread:

```python
import threading

@app.post("/stop", status_code=200)
async def stop_service():
    sd.stop()
    def _exit():
        import time; time.sleep(0.1)
        os._exit(0)
    threading.Thread(target=_exit, daemon=True).start()
    return JSONResponse({"status": "stopped"})
```

This returns the response before os._exit(0) fires. The 0.1s sleep is enough for FastAPI
to flush the response buffer.

From 05-RESEARCH.md (Pattern 3 — save_config atomic write):
```python
import json, threading, pathlib

_CONFIG_LOCK = threading.Lock()

def save_config(state: dict) -> None:
    path = _config_path()
    path.parent.mkdir(parents=True, exist_ok=True)
    persisted = {
        "voice":         state.get("voice", "af_heart"),
        "speed":         state.get("speed", 1.0),
        "volume":        state.get("volume", 1.0),
        "model":         state.get("model", "kokoro"),
        "muted":         state.get("muted", False),
        "pre_cue_path":  state.get("pre_cue_path"),
        "post_cue_path": state.get("post_cue_path"),
    }
    tmp = path.with_suffix(".json.tmp")
    with _CONFIG_LOCK:
        tmp.write_text(json.dumps(persisted, indent=2), encoding="utf-8")
        tmp.replace(path)
    logging.debug("Config saved to %s", path)
```

From 05-RESEARCH.md (Pattern 6 — full STATE hydration at startup):
```python
_cfg = load_config()
for key in ("voice", "speed", "volume", "model", "muted", "pre_cue_path", "post_cue_path"):
    if key in _cfg and _cfg[key] is not None:
        STATE[key] = _cfg[key]
        logging.info("Config restored: %s = %s", key, STATE[key])
```
</interfaces>
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add save_config() to config_loader.py</name>
  <files>agenttalk/config_loader.py</files>
  <action>
    Modify `agenttalk/config_loader.py`. Add `save_config()` below the existing `load_config()`.
    Do NOT rewrite the file — append after the existing function.

    **Step 1: Add import for threading** at the top of the file (alongside existing imports):
    Add `import threading` to the import block.

    **Step 2: Add _CONFIG_LOCK module-level constant** after the existing `_config_path()` function
    but before `load_config()`:
    ```python
    _CONFIG_LOCK = threading.Lock()
    ```

    **Step 3: Append save_config() at the end of the file:**
    ```python
    def save_config(state: dict) -> None:
        """
        Persist runtime state to config.json atomically.

        Writes to .json.tmp then calls Path.replace() — atomic on Windows
        (os.replace() is guaranteed atomic within the same filesystem, Python 3.3+).

        Thread-safe via _CONFIG_LOCK — both the FastAPI handler thread and
        the tts_worker thread could call this concurrently.

        CFG-01: Writes to %APPDATA%/AgentTalk/config.json (no admin rights).
        CFG-02: Persists all 7 settings fields.
        """
        path = _config_path()
        path.parent.mkdir(parents=True, exist_ok=True)

        persisted = {
            "voice":         state.get("voice", "af_heart"),
            "speed":         state.get("speed", 1.0),
            "volume":        state.get("volume", 1.0),
            "model":         state.get("model", "kokoro"),
            "muted":         state.get("muted", False),
            "pre_cue_path":  state.get("pre_cue_path"),
            "post_cue_path": state.get("post_cue_path"),
        }

        tmp = path.with_suffix(".json.tmp")
        with _CONFIG_LOCK:
            tmp.write_text(json.dumps(persisted, indent=2), encoding="utf-8")
            tmp.replace(path)  # os.replace() — atomic on Windows
        logging.debug("Config saved to %s", path)
    ```

    Also update the module docstring to mention Phase 5 write support is now present (change the
    "Phase 5 will add write support" comment to "Phase 5: save_config() added for runtime persistence.").
  </action>
  <verify>
    **Import and function exists:**
    ```bash
    cd /d/docker/claudetalk && python -c "
    from agenttalk.config_loader import load_config, save_config, _CONFIG_LOCK
    import threading
    assert isinstance(_CONFIG_LOCK, type(threading.Lock()))
    print('save_config and _CONFIG_LOCK exist')
    "
    ```
    Prints "save_config and _CONFIG_LOCK exist".

    **Round-trip test — save then load:**
    ```bash
    cd /d/docker/claudetalk && python -c "
    import os, pathlib, tempfile
    from agenttalk import config_loader

    # Redirect config path to a temp file
    tmp_dir = pathlib.Path(tempfile.mkdtemp())
    orig = config_loader._config_path
    config_loader._config_path = lambda: tmp_dir / 'config.json'

    state = {
        'voice': 'af_bella',
        'speed': 1.2,
        'volume': 0.8,
        'model': 'kokoro',
        'muted': True,
        'pre_cue_path': 'C:/bell.wav',
        'post_cue_path': None,
    }
    config_loader.save_config(state)

    loaded = config_loader.load_config()
    assert loaded['voice'] == 'af_bella', f'voice mismatch: {loaded}'
    assert loaded['speed'] == 1.2
    assert loaded['muted'] is True
    assert loaded['pre_cue_path'] == 'C:/bell.wav'
    assert 'post_cue_path' in loaded
    print('save_config round-trip OK')

    config_loader._config_path = orig
    import shutil; shutil.rmtree(tmp_dir)
    "
    ```
    Prints "save_config round-trip OK".

    **Verify tmp file is cleaned up (no .json.tmp left):**
    After the round-trip test, check that the tmp file is gone (Path.replace() should have moved it).
    The test above removes the temp directory, which indirectly confirms this. Add this assertion
    inside the test block above:
    ```python
    assert not (tmp_dir / 'config.json.tmp').exists(), '.json.tmp not cleaned up'
    ```
  </verify>
  <done>
    config_loader.py exports both load_config() and save_config(). save_config() writes all 7 CFG-02 fields atomically via .json.tmp + Path.replace(). _CONFIG_LOCK prevents concurrent write corruption. Round-trip save/load test passes.
  </done>
</task>

<task type="auto">
  <name>Task 2: Add model/piper_model_path to STATE, POST /config and POST /stop to service.py, and full 7-key config hydration at startup</name>
  <files>agenttalk/tts_worker.py, agenttalk/service.py</files>
  <action>
    **Part A: Extend STATE dict in agenttalk/tts_worker.py**

    The current STATE dict (Phase 4) has 7 keys. Add 2 more for engine switching:
    Find the STATE dict definition and add these two entries:
    ```python
    STATE: dict = {
        "volume": 1.0,
        "speed": 1.0,
        "voice": "af_heart",
        "muted": False,
        "speaking": False,
        "pre_cue_path": None,
        "post_cue_path": None,
        "model": "kokoro",          # TTS engine: "kokoro" or "piper" (TTS-04)
        "piper_model_path": None,   # Absolute path to Piper ONNX model file (TTS-04)
    }
    ```
    Also update the module docstring to mention Phase 5 additions: `"model"` and `"piper_model_path"` keys,
    and reference TTS-04 (Piper engine, switchable via /agenttalk:model).

    **Part B: Update service.py — add save_config import, /config and /stop endpoints, full config hydration**

    Open `agenttalk/service.py` and make the following targeted changes:

    **Step 1: Update the config_loader import line.**
    Find:
    ```python
    from agenttalk.config_loader import load_config
    ```
    Replace with:
    ```python
    from agenttalk.config_loader import load_config, save_config
    ```

    **Step 2: Add Optional import.** Find the existing pydantic import:
    ```python
    from pydantic import BaseModel
    ```
    Replace with:
    ```python
    from typing import Optional
    from pydantic import BaseModel
    ```

    **Step 3: Add ConfigRequest model.** After the existing `SpeakRequest` class definition, add:
    ```python
    class ConfigRequest(BaseModel):
        """Request body for POST /config — all fields optional (partial update)."""
        voice: Optional[str] = None
        speed: Optional[float] = None
        volume: Optional[float] = None
        model: Optional[str] = None       # "kokoro" or "piper"
        muted: Optional[bool] = None
        pre_cue_path: Optional[str] = None
        post_cue_path: Optional[str] = None
    ```

    **Step 4: Add POST /config endpoint.** After the existing `@app.post("/speak")` endpoint, add:
    ```python
    @app.post("/config", status_code=200)
    async def update_config(req: ConfigRequest):
        """
        Update one or more runtime settings. Changes take effect immediately (CFG-03).
        Persists all settings to config.json after each update (CFG-01, CFG-02).

        Returns:
            200 + {"status": "ok", "updated": [...]}  — keys updated in STATE and saved to disk
            200 + {"status": "ok", "updated": []}     — empty body (no-op)
        """
        updates = req.model_dump(exclude_none=True)
        for key, value in updates.items():
            if key in STATE:
                STATE[key] = value
                logging.info("Config updated: %s = %s", key, value)
        save_config(STATE)
        return JSONResponse({"status": "ok", "updated": list(updates.keys())})


    @app.post("/stop", status_code=200)
    async def stop_service():
        """
        Silence current TTS and terminate the service process.

        Calls sd.stop() immediately, then schedules os._exit(0) in a daemon thread
        with a 0.1s delay so the HTTP response is returned before the process exits.
        (os._exit(0) terminates without waiting for threads — same as _on_quit().)

        CMD-02: /agenttalk:stop slash command calls this endpoint.
        """
        sd.stop()  # Interrupt any currently playing audio immediately

        def _exit():
            import time
            time.sleep(0.1)
            os._exit(0)

        threading.Thread(target=_exit, daemon=True).start()
        return JSONResponse({"status": "stopped"})
    ```

    **Step 5: Replace the partial config hydration block in main() with full 7-key hydration.**
    Find the existing startup config block (added in Phase 4):
    ```python
    # CUE-04: Load persisted config and seed cue paths into STATE before the tray starts.
    # Phase 5 will add write support; Phase 4 reads only.
    _cfg = load_config()
    if _cfg.get("pre_cue_path"):
        STATE["pre_cue_path"] = _cfg["pre_cue_path"]
        logging.info("Config: pre_cue_path = %s", STATE["pre_cue_path"])
    if _cfg.get("post_cue_path"):
        STATE["post_cue_path"] = _cfg["post_cue_path"]
        logging.info("Config: post_cue_path = %s", STATE["post_cue_path"])
    ```
    Replace with:
    ```python
    # CFG-01, CFG-02, CFG-03: Restore all persisted settings from config.json at startup.
    # This ensures voice, model, speed, volume, mute, and cue paths survive restarts.
    _cfg = load_config()
    for _key in ("voice", "speed", "volume", "model", "muted", "pre_cue_path", "post_cue_path"):
        if _key in _cfg and _cfg[_key] is not None:
            STATE[_key] = _cfg[_key]
            logging.info("Config restored: %s = %s", _key, STATE[_key])
    ```

    NOTE: The `sd` variable (sounddevice) must be importable in the /stop endpoint handler. It is already
    imported at the top of service.py as `import sounddevice as sd`. Confirm this import exists; if not,
    add it alongside the existing imports.

    NOTE: `threading` is already imported in service.py. Confirm before adding a duplicate import.
  </action>
  <verify>
    **Static import check — all new symbols present:**
    ```bash
    cd /d/docker/claudetalk && python -c "
    import agenttalk.service as s
    import agenttalk.tts_worker as w
    # Check STATE has new keys
    assert 'model' in w.STATE, 'model key missing from STATE'
    assert 'piper_model_path' in w.STATE, 'piper_model_path key missing from STATE'
    assert w.STATE['model'] == 'kokoro', f'default model wrong: {w.STATE[\"model\"]}'
    # Check endpoints registered
    routes = [r.path for r in s.app.routes]
    assert '/config' in routes, f'/config not registered: {routes}'
    assert '/stop' in routes, f'/stop not registered: {routes}'
    print('STATE new keys:', w.STATE['model'], w.STATE['piper_model_path'])
    print('Routes include /config and /stop')
    print('Task 2 imports OK')
    "
    ```
    Prints the expected output without errors.

    **Verify save_config is imported in service.py:**
    ```bash
    grep -n "save_config" /d/docker/claudetalk/agenttalk/service.py
    ```
    Shows the import line and usage in update_config().

    **Verify full 7-key config hydration loop in service.py:**
    ```bash
    grep -n "for _key in" /d/docker/claudetalk/agenttalk/service.py
    ```
    Shows the for-loop iterating over all 7 CFG-02 keys.

    **Verify partial Phase 4 cue-only block is removed:**
    ```bash
    grep -n "Phase 5 will add write support" /d/docker/claudetalk/agenttalk/service.py
    ```
    No output (the old comment must be gone).

    **Verify /stop uses 0.1s delayed exit thread pattern:**
    ```bash
    grep -n "_exit\|time.sleep" /d/docker/claudetalk/agenttalk/service.py
    ```
    Shows the daemon thread and sleep(0.1) inside the /stop handler.

    **Live /config round-trip test (requires service running — skip if not available):**
    The automated tests above cover the static structure. Runtime testing is deferred to the
    phase-level verification step.

    **Existing test suite passes (regression):**
    ```bash
    cd /d/docker/claudetalk && python -m pytest tests/ -v
    ```
    All pre-existing tests pass.
  </verify>
  <done>
    tts_worker.STATE has 'model' (default 'kokoro') and 'piper_model_path' (default None) keys. service.py imports save_config. POST /config endpoint updates matching STATE keys and calls save_config(STATE). POST /stop calls sd.stop() then os._exit(0) via 0.1s-delayed daemon thread. main() uses a 7-key for-loop to hydrate STATE from config.json at startup. All existing tests pass.
  </done>
</task>

</tasks>

<verification>
Run after both tasks complete:

**1. All new symbols importable and correct defaults:**
```bash
cd /d/docker/claudetalk && python -c "
from agenttalk.config_loader import load_config, save_config, _CONFIG_LOCK
from agenttalk.tts_worker import STATE
import agenttalk.service as svc
import threading

assert hasattr(save_config, '__call__')
assert isinstance(_CONFIG_LOCK, type(threading.Lock()))
assert STATE['model'] == 'kokoro'
assert STATE['piper_model_path'] is None
routes = [r.path for r in svc.app.routes]
assert '/config' in routes
assert '/stop' in routes
print('All Phase 5-01 symbols OK')
"
```
Prints "All Phase 5-01 symbols OK".

**2. save_config round-trip (all 7 CFG-02 fields):**
```bash
cd /d/docker/claudetalk && python -c "
import pathlib, tempfile, shutil
from agenttalk import config_loader

tmp_dir = pathlib.Path(tempfile.mkdtemp())
orig = config_loader._config_path
config_loader._config_path = lambda: tmp_dir / 'config.json'

state = {'voice':'af_sky','speed':0.9,'volume':1.1,'model':'piper','muted':False,'pre_cue_path':None,'post_cue_path':'C:/post.wav'}
config_loader.save_config(state)
loaded = config_loader.load_config()
assert loaded['voice'] == 'af_sky'
assert loaded['model'] == 'piper'
assert loaded['post_cue_path'] == 'C:/post.wav'
assert not (tmp_dir / 'config.json.tmp').exists()
print('save_config CFG-02 all 7 fields OK')

config_loader._config_path = orig
shutil.rmtree(tmp_dir)
"
```
Prints "save_config CFG-02 all 7 fields OK".

**3. Full config hydration replaces partial Phase 4 block:**
```bash
grep -c "pre_cue_path\|post_cue_path" /d/docker/claudetalk/agenttalk/service.py
grep -n "for _key in" /d/docker/claudetalk/agenttalk/service.py
```
- First command: shows pre/post cue path mentioned in the hydration loop.
- Second command: shows the 7-key for-loop present.

**4. Existing test suite passes:**
```bash
cd /d/docker/claudetalk && python -m pytest tests/ -v
```
All tests pass.
</verification>

<success_criteria>
- config_loader.py exports save_config(state) that atomically writes all 7 CFG-02 fields to config.json via tmp + Path.replace() — no partial writes (CFG-01)
- _CONFIG_LOCK threading.Lock() guards concurrent save_config() calls (CFG-01 thread safety)
- tts_worker.STATE has 'model' (default 'kokoro') and 'piper_model_path' (default None) — required by Plan 05-02 Piper engine switching
- POST /config accepts partial ConfigRequest, updates matching STATE keys immediately, calls save_config(STATE) — changes take effect on next synthesis without restart (CFG-03)
- POST /config returns {"status": "ok", "updated": [...keys...]} on success (CMD-03 service side)
- POST /stop calls sd.stop() (silences current audio) then terminates via os._exit(0) in a delayed daemon thread so the HTTP response is delivered first (CMD-02 service side)
- service.py main() restores all 7 config fields from config.json at startup via a for-loop — voice, speed, volume, model, muted, pre/post cue paths (CFG-02 read-back on restart)
- All Phase 1-4 tests pass — no regression
</success_criteria>

<output>
After completion, create `.planning/phases/05-configuration-voice-model-switching-and-slash-commands/05-01-SUMMARY.md`
</output>
