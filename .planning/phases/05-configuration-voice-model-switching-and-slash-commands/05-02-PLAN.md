---
phase: 05-configuration-voice-model-switching-and-slash-commands
plan: "02"
type: execute
wave: 2
depends_on:
  - "05-01"
files_modified:
  - agenttalk/piper_engine.py
  - agenttalk/tts_worker.py
autonomous: true
requirements:
  - TTS-04
  - CMD-04

must_haves:
  truths:
    - "agenttalk/piper_engine.py exists and contains PiperEngine class with create(text, voice, speed, lang) -> (np.ndarray[float32], int) interface matching Kokoro"
    - "PiperEngine.__init__(model_path) calls PiperVoice.load(model_path) — lazy per-instance, not at import time"
    - "PiperEngine.create() maps speed to SynthesisConfig(length_scale=1.0/speed), reads WAV bytes, converts int16 to float32 samples"
    - "tts_worker.py has a module-level _piper_engine = None and _get_active_engine(kokoro) function"
    - "_get_active_engine returns the Kokoro engine when STATE['model'] == 'kokoro'"
    - "_get_active_engine returns a lazy-loaded PiperEngine when STATE['model'] == 'piper' — raises RuntimeError with clear message if STATE['piper_model_path'] is None"
    - "_tts_worker() calls _get_active_engine(kokoro_engine) per synthesis call instead of calling kokoro_engine.create() directly"
    - "Switching STATE['model'] to 'piper' causes the next /speak request to use PiperEngine — no service restart required (CMD-04, CFG-03)"
    - "PiperEngine is NOT imported or instantiated at startup — only when STATE['model'] first becomes 'piper' (lazy load)"
  artifacts:
    - path: "agenttalk/piper_engine.py"
      provides: "PiperEngine class — thin wrapper around PiperVoice with same interface as Kokoro"
      exports: ["PiperEngine"]
    - path: "agenttalk/tts_worker.py"
      provides: "_get_active_engine() engine dispatcher; _piper_engine module-level lazy instance; _tts_worker uses engine dispatcher"
      contains: "_get_active_engine"
  key_links:
    - from: "agenttalk/tts_worker.py"
      to: "agenttalk/piper_engine.py"
      via: "from agenttalk.piper_engine import PiperEngine (deferred import inside _get_active_engine)"
      pattern: "from agenttalk\\.piper_engine import"
---

<objective>
Add the Piper TTS engine wrapper and wire it into the TTS worker as a runtime-switchable alternative to Kokoro.

Purpose: TTS-04 requires Piper as an alternate engine switchable via /agenttalk:model. The /config endpoint (Plan 05-01) already writes STATE['model']. This plan adds the PiperEngine class and updates _tts_worker() to dispatch to the active engine at synthesis time. Lazy loading prevents Piper's 2-5s init cost from affecting every startup.

Output: New agenttalk/piper_engine.py (PiperEngine class). Modified agenttalk/tts_worker.py (_get_active_engine dispatcher, _piper_engine module-level instance, _tts_worker calls dispatcher).
</objective>

<execution_context>
@C:/Users/omern/.claude/get-shit-done/workflows/execute-plan.md
@C:/Users/omern/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/05-configuration-voice-model-switching-and-slash-commands/05-RESEARCH.md
@.planning/phases/05-configuration-voice-model-switching-and-slash-commands/05-01-SUMMARY.md

<interfaces>
<!-- Contracts from Plan 05-01 output and existing codebase. No exploration needed. -->

From agenttalk/tts_worker.py (after Plan 05-01):
```python
STATE: dict = {
    "volume": 1.0,
    "speed": 1.0,
    "voice": "af_heart",
    "muted": False,
    "speaking": False,
    "pre_cue_path": None,
    "post_cue_path": None,
    "model": "kokoro",          # NEW from Plan 05-01
    "piper_model_path": None,   # NEW from Plan 05-01
}
```

From agenttalk/tts_worker.py — current synthesis call in _tts_worker() (target for replacement):
```python
samples, rate = kokoro_engine.create(
    sentence,
    voice=STATE["voice"],
    speed=STATE["speed"],
    lang="en-us",
)
```

From 05-RESEARCH.md (Pattern 4 — PiperEngine wrapper):
```python
import io, wave
import numpy as np
from piper_tts import PiperVoice, SynthesisConfig

class PiperEngine:
    def __init__(self, model_path: str):
        self._voice = PiperVoice.load(model_path)
        self._sample_rate = 22050  # Piper default; overwritten by actual WAV framerate

    def create(self, text: str, voice: str = None, speed: float = 1.0, lang: str = "en-us"):
        """
        Synthesize text. Returns (float32 samples, sample_rate).
        'voice' param is ignored — Piper uses the model's built-in voice.
        'speed' maps to SynthesisConfig(length_scale=1.0/speed).
        """
        cfg = SynthesisConfig(length_scale=1.0 / max(speed, 0.1))
        buf = io.BytesIO()
        with wave.open(buf, "wb") as wf:
            self._voice.synthesize_wav(text, wf, syn_config=cfg)
        buf.seek(0)
        with wave.open(buf, "rb") as wf:
            raw = wf.readframes(wf.getnframes())
            self._sample_rate = wf.getframerate()
        samples = np.frombuffer(raw, dtype=np.int16).astype(np.float32) / 32768.0
        return samples, self._sample_rate
```

From 05-RESEARCH.md (engine dispatcher pattern):
```python
# Module-level in tts_worker.py:
_piper_engine = None   # Lazy-loaded on first Piper synthesis

def _get_active_engine(kokoro):
    """Return the active TTS engine based on STATE['model']."""
    global _piper_engine
    model = STATE.get("model", "kokoro")
    if model == "piper":
        if _piper_engine is None:
            piper_path = STATE.get("piper_model_path")
            if not piper_path:
                raise RuntimeError(
                    "Piper model path not configured. "
                    "Run agenttalk setup --piper to download a model."
                )
            from agenttalk.piper_engine import PiperEngine
            _piper_engine = PiperEngine(piper_path)
        return _piper_engine
    return kokoro  # default: Kokoro
```

CRITICAL — sample rate from engine return value:
The _tts_worker loop currently uses `rate` returned by kokoro_engine.create(). Piper returns
22050 Hz (not 24000 Hz). As long as the code reads `rate` from the engine's return tuple,
sounddevice will receive the correct sample rate automatically. NEVER hardcode 24000.

CRITICAL — lazy import:
The `from agenttalk.piper_engine import PiperEngine` import must be INSIDE _get_active_engine,
not at the top of tts_worker.py. piper-tts has a 2-5s import cost and must not affect
startup when the user is using Kokoro only. If piper-tts is not installed, the import error
occurs only when the user explicitly switches to Piper.

CRITICAL — piper_model_path open question:
Research confirms that Phase 5 stores the Piper model path in STATE["piper_model_path"].
If the user has not set this (the default is None), _get_active_engine raises RuntimeError
with a clear message. This is surfaced to the TTS worker's exception handler and logged.
Phase 6 (agenttalk setup --piper) handles model download and path configuration.

CRITICAL — _piper_engine is NOT reset when STATE["model"] switches back to "kokoro":
Once PiperEngine is loaded, it stays in memory. Switching back to "kokoro" uses the
kokoro argument passed to _get_active_engine(). Switching to "piper" again reuses the
cached _piper_engine. This is correct behavior (avoids repeated slow init).
</interfaces>
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create agenttalk/piper_engine.py — PiperEngine wrapper class</name>
  <files>agenttalk/piper_engine.py</files>
  <action>
    Create a new file `agenttalk/piper_engine.py` with the following content:

    ```python
    """
    piper_engine.py — Thin wrapper around piper-tts (OHF-Voice/piper1-gpl) that
    exposes the same interface as Kokoro:

        create(text, voice, speed, lang) -> (np.ndarray[float32], int sample_rate)

    This allows tts_worker._get_active_engine() to return either Kokoro or PiperEngine
    and call create() without branching on the engine type.

    TTS-04: Piper TTS available as alternate engine, switchable at runtime via /agenttalk:model.

    LAZY LOADING:
    piper-tts is NOT imported at module level. PiperVoice.load() is called in __init__
    only when PiperEngine is first instantiated (triggered by STATE['model'] == 'piper').
    This prevents the 2-5s Piper init cost from affecting startup when Kokoro is the
    active engine.

    VOICE PARAMETER:
    Piper uses the voice model baked into the .onnx file. The 'voice' parameter accepted
    by create() is ignored — it exists only to match the Kokoro interface.

    SAMPLE RATE:
    Piper outputs 22050 Hz by default. The actual framerate is read from the synthesized
    WAV buffer and returned as the second element of the create() tuple so that
    sounddevice receives the correct sample rate automatically.

    SPEED MAPPING:
    Piper's SynthesisConfig.length_scale is the inverse of speech speed:
        length_scale = 1.0 / speed
    A speed of 1.5 → length_scale = 0.67 (faster).
    A speed of 0.5 → length_scale = 2.0 (slower).
    Minimum speed is clamped to 0.1 to prevent division-by-zero.
    """
    import io
    import logging
    import wave

    import numpy as np


    class PiperEngine:
        """
        Piper TTS engine wrapper with Kokoro-compatible interface.

        Args:
            model_path: Absolute path to a Piper ONNX voice model file
                        (e.g., %APPDATA%\\AgentTalk\\models\\piper\\en_US-lessac-medium.onnx).
                        The corresponding .json config file must exist at the same path
                        with a .json extension (piper-tts loads it automatically).

        Raises:
            FileNotFoundError: If model_path does not exist.
            ImportError: If piper-tts package is not installed (pip install piper-tts).
        """

        def __init__(self, model_path: str):
            from piper_tts import PiperVoice  # deferred import — lazy load
            logging.info("Loading Piper model from %s ...", model_path)
            self._voice = PiperVoice.load(model_path)
            self._sample_rate = 22050  # Piper default; updated from actual WAV framerate after first synthesis
            logging.info("Piper model loaded.")

        def create(
            self,
            text: str,
            voice: str = None,
            speed: float = 1.0,
            lang: str = "en-us",
        ) -> tuple:
            """
            Synthesize text to audio samples.

            Args:
                text:  Text to synthesize.
                voice: Ignored — Piper uses the model's built-in voice.
                speed: Speech speed multiplier (0.1–2.0). Mapped to length_scale = 1/speed.
                lang:  Ignored — Piper language is determined by the model.

            Returns:
                (samples, sample_rate):
                    samples: np.ndarray[float32] in range [-1.0, 1.0]
                    sample_rate: int (typically 22050 Hz for Piper)
            """
            from piper_tts import SynthesisConfig  # deferred import

            # Clamp speed to avoid division-by-zero
            safe_speed = max(float(speed), 0.1)
            cfg = SynthesisConfig(length_scale=1.0 / safe_speed)

            # Synthesize to an in-memory WAV buffer
            buf = io.BytesIO()
            with wave.open(buf, "wb") as wf:
                self._voice.synthesize_wav(text, wf, syn_config=cfg)

            # Read back: extract raw PCM bytes and actual sample rate
            buf.seek(0)
            with wave.open(buf, "rb") as wf:
                raw = wf.readframes(wf.getnframes())
                self._sample_rate = wf.getframerate()

            # Convert int16 PCM → float32 in [-1.0, 1.0]
            samples = np.frombuffer(raw, dtype=np.int16).astype(np.float32) / 32768.0
            return samples, self._sample_rate
    ```

    NOTE: The file uses deferred imports for `PiperVoice` and `SynthesisConfig` (inside __init__
    and create() respectively). This means importing `piper_engine.py` at module level is safe
    even if piper-tts is not installed — the ImportError only occurs when PiperEngine() is
    instantiated.
  </action>
  <verify>
    **Module imports cleanly (piper-tts does NOT need to be installed for import):**
    ```bash
    cd /d/docker/claudetalk && python -c "
    import agenttalk.piper_engine
    print('piper_engine.py module-level import OK (no piper-tts needed at import time)')
    "
    ```
    Prints "piper_engine.py module-level import OK" without error. ImportError must NOT occur
    here because piper-tts is not necessarily installed.

    **PiperEngine class is exported:**
    ```bash
    cd /d/docker/claudetalk && python -c "
    from agenttalk.piper_engine import PiperEngine
    print('PiperEngine class importable')
    print('create signature:', PiperEngine.create.__code__.co_varnames[:5])
    "
    ```
    Prints "PiperEngine class importable".

    **Interface matches Kokoro (structural check):**
    ```bash
    cd /d/docker/claudetalk && python -c "
    import inspect
    from agenttalk.piper_engine import PiperEngine
    sig = inspect.signature(PiperEngine.create)
    params = list(sig.parameters.keys())
    assert 'text' in params, 'text param missing'
    assert 'voice' in params, 'voice param missing'
    assert 'speed' in params, 'speed param missing'
    assert 'lang' in params, 'lang param missing'
    print('PiperEngine.create interface matches Kokoro:', params)
    "
    ```
    Prints the parameter list confirming Kokoro-compatible interface.
  </verify>
  <done>
    agenttalk/piper_engine.py exists. Module-level import succeeds without piper-tts installed. PiperEngine class has create(text, voice, speed, lang) method with Kokoro-compatible interface. Deferred imports prevent startup cost when Kokoro is the active engine.
  </done>
</task>

<task type="auto">
  <name>Task 2: Add _get_active_engine() dispatcher and _piper_engine to tts_worker.py</name>
  <files>agenttalk/tts_worker.py</files>
  <action>
    Modify `agenttalk/tts_worker.py`. Make targeted additions only — do NOT rewrite the file.

    **Step 1: Add _piper_engine module-level variable** after the existing module-level state block
    (after _icon_ref = None):
    ```python
    # Lazy-loaded Piper engine instance — None until STATE['model'] first switches to 'piper'.
    # _get_active_engine() creates it on demand. Once loaded, reused for all subsequent Piper synthesis.
    _piper_engine = None
    ```

    **Step 2: Add _get_active_engine() function** before the `start_tts_worker()` function:
    ```python
    def _get_active_engine(kokoro):
        """
        Return the active TTS engine based on STATE['model'].

        When model == 'kokoro' (default): returns the Kokoro engine passed as argument.
        When model == 'piper': lazy-loads PiperEngine on first call using STATE['piper_model_path'].

        Args:
            kokoro: The Kokoro engine instance (passed from _tts_worker via start_tts_worker).

        Returns:
            An engine with a create(text, voice, speed, lang) -> (samples, rate) interface.

        Raises:
            RuntimeError: If model == 'piper' and piper_model_path is not configured in STATE.
            ImportError: If model == 'piper' and piper-tts package is not installed.
            FileNotFoundError: If model == 'piper' and the model file does not exist.

        TTS-04: Piper TTS switchable at runtime via /agenttalk:model without service restart.
        CFG-03: STATE['model'] is updated by POST /config; next synthesis call uses new engine.
        """
        global _piper_engine
        model = STATE.get("model", "kokoro")
        if model == "piper":
            if _piper_engine is None:
                piper_path = STATE.get("piper_model_path")
                if not piper_path:
                    raise RuntimeError(
                        "Piper model path not configured. "
                        "Run 'agenttalk setup --piper' to download a model, "
                        "or set piper_model_path in config.json."
                    )
                from agenttalk.piper_engine import PiperEngine  # deferred — lazy load
                logging.info("Initialising Piper engine from %s", piper_path)
                _piper_engine = PiperEngine(piper_path)
            return _piper_engine
        # Default: Kokoro
        return kokoro
    ```

    **Step 3: Replace the direct kokoro_engine.create() call in _tts_worker()** with a call
    through _get_active_engine().

    Find this block inside the for-loop in _tts_worker():
    ```python
                    logging.debug("TTS: synthesizing %r", sentence[:60])
                    samples, rate = kokoro_engine.create(
                        sentence,
                        voice=STATE["voice"],
                        speed=STATE["speed"],
                        lang="en-us",
                    )
    ```

    Replace with:
    ```python
                    logging.debug("TTS: synthesizing %r", sentence[:60])
                    engine = _get_active_engine(kokoro_engine)
                    samples, rate = engine.create(
                        sentence,
                        voice=STATE["voice"],
                        speed=STATE["speed"],
                        lang="en-us",
                    )
    ```

    IMPORTANT: The `engine` local variable is assigned inside the for-loop, not outside it.
    This means the engine can switch mid-batch if STATE['model'] changes (unlikely but safe).
    The `rate` value from engine.create() is passed directly to sd.play(scaled, samplerate=rate)
    — do NOT hardcode 24000. Piper returns 22050 Hz; this must be honoured.

    NOTE: The existing exception handler in _tts_worker() already catches all exceptions and
    logs them. RuntimeError from _get_active_engine (no piper_model_path configured) will be
    caught here and logged, skipping the batch. This is the correct behavior.
  </action>
  <verify>
    **Module-level state check:**
    ```bash
    cd /d/docker/claudetalk && python -c "
    import agenttalk.tts_worker as w
    assert '_piper_engine' in dir(w), '_piper_engine not in module'
    assert w._piper_engine is None, '_piper_engine should be None at startup'
    assert hasattr(w, '_get_active_engine'), '_get_active_engine function missing'
    print('_piper_engine:', w._piper_engine)
    print('_get_active_engine exists:', callable(w._get_active_engine))
    print('tts_worker Phase 5-02 additions OK')
    "
    ```
    Prints expected output without error.

    **_get_active_engine returns Kokoro when model == 'kokoro':**
    ```bash
    cd /d/docker/claudetalk && python -c "
    import agenttalk.tts_worker as w
    w.STATE['model'] = 'kokoro'
    sentinel = object()  # fake kokoro engine
    result = w._get_active_engine(sentinel)
    assert result is sentinel, f'Expected kokoro sentinel, got {result}'
    print('_get_active_engine returns kokoro for model=kokoro OK')
    "
    ```
    Prints "returns kokoro for model=kokoro OK".

    **_get_active_engine raises RuntimeError when model == 'piper' with no path:**
    ```bash
    cd /d/docker/claudetalk && python -c "
    import agenttalk.tts_worker as w
    w.STATE['model'] = 'piper'
    w.STATE['piper_model_path'] = None
    w._piper_engine = None  # ensure not cached
    try:
        w._get_active_engine(None)
        print('ERROR: should have raised RuntimeError')
    except RuntimeError as e:
        print('RuntimeError raised correctly:', str(e)[:60])
    finally:
        w.STATE['model'] = 'kokoro'  # restore
    "
    ```
    Prints "RuntimeError raised correctly: Piper model path not configured..."

    **Verify direct kokoro_engine.create() is replaced with engine.create():**
    ```bash
    grep -n "kokoro_engine.create\|engine.create\|_get_active_engine" /d/docker/claudetalk/agenttalk/tts_worker.py
    ```
    - No line should show `kokoro_engine.create(` inside the synthesis loop.
    - Lines should show `_get_active_engine(kokoro_engine)` and `engine.create(`.

    **Existing test suite passes (regression):**
    ```bash
    cd /d/docker/claudetalk && python -m pytest tests/ -v
    ```
    All tests pass.
  </verify>
  <done>
    tts_worker.py has _piper_engine = None at module level. _get_active_engine(kokoro) returns the Kokoro engine when STATE['model'] == 'kokoro' and lazy-loads PiperEngine when STATE['model'] == 'piper'. _tts_worker() calls _get_active_engine() per sentence, not kokoro_engine.create() directly. RuntimeError is raised (and caught by the existing exception handler) when Piper is requested but piper_model_path is None. All existing tests pass.
  </done>
</task>

</tasks>

<verification>
Run after both tasks complete:

**1. Full import chain including piper_engine:**
```bash
cd /d/docker/claudetalk && python -c "
import agenttalk.service
import agenttalk.tts_worker
import agenttalk.piper_engine
import agenttalk.config_loader
print('All Phase 5-02 modules import OK')
"
```
Prints "All Phase 5-02 modules import OK".

**2. Engine dispatcher correctness:**
```bash
cd /d/docker/claudetalk && python -c "
import agenttalk.tts_worker as w
# Kokoro path
w.STATE['model'] = 'kokoro'
fake_kokoro = object()
assert w._get_active_engine(fake_kokoro) is fake_kokoro

# Piper path — no model path → RuntimeError
w.STATE['model'] = 'piper'
w.STATE['piper_model_path'] = None
w._piper_engine = None
try:
    w._get_active_engine(None)
    assert False, 'Should have raised'
except RuntimeError:
    pass

w.STATE['model'] = 'kokoro'
print('Engine dispatcher tests passed')
"
```
Prints "Engine dispatcher tests passed".

**3. Direct kokoro_engine.create() call is gone from synthesis loop:**
```bash
grep -n "kokoro_engine.create" /d/docker/claudetalk/agenttalk/tts_worker.py
```
No output — direct call must not exist in the synthesis loop.

**4. engine.create() and _get_active_engine present:**
```bash
grep -n "_get_active_engine\|engine.create" /d/docker/claudetalk/agenttalk/tts_worker.py
```
Shows both lines in the _tts_worker synthesis block.

**5. Existing tests pass:**
```bash
cd /d/docker/claudetalk && python -m pytest tests/ -v
```
All tests pass.
</verification>

<success_criteria>
- agenttalk/piper_engine.py exists with PiperEngine class — module-level import succeeds even without piper-tts installed (deferred import) (TTS-04)
- PiperEngine.create() interface matches Kokoro: accepts (text, voice, speed, lang), returns (float32 ndarray, int sample_rate) (TTS-04)
- PiperEngine maps speed to SynthesisConfig(length_scale=1.0/speed) — speed=1.5 sounds faster than 1.0 (TTS-04)
- tts_worker._piper_engine = None at startup — Piper is NOT loaded until user switches model (lazy load, no startup penalty)
- tts_worker._get_active_engine(kokoro) returns kokoro when STATE['model'] == 'kokoro' (default path unaffected)
- _get_active_engine raises RuntimeError with actionable message when model == 'piper' and piper_model_path is None
- _tts_worker synthesis loop calls _get_active_engine(kokoro_engine).create() — sd.play uses returned rate (never hardcoded 24000)
- Switching STATE['model'] to 'piper' via POST /config (Plan 05-01) causes the next synthesis call to use PiperEngine (CMD-04, CFG-03)
- All Phase 1-4 tests pass after changes
</success_criteria>

<output>
After completion, create `.planning/phases/05-configuration-voice-model-switching-and-slash-commands/05-02-SUMMARY.md`
</output>
