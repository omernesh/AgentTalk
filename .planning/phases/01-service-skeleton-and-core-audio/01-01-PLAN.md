---
phase: 01-service-skeleton-and-core-audio
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - requirements.txt
  - agenttalk/service.py
autonomous: true
requirements:
  - SVC-01
  - SVC-06

must_haves:
  truths:
    - "Running `pythonw.exe agenttalk/service.py` produces no console window"
    - "All log output is written to `%APPDATA%\\AgentTalk\\agenttalk.log` — nothing to stdout"
    - "`pip install -r requirements.txt` succeeds on Python 3.11 in a clean venv"
    - "Importing `kokoro_onnx` succeeds without DLL errors (espeakng-loader validation)"
    - "The `%APPDATA%\\AgentTalk\\` directory is created automatically on first run"
  artifacts:
    - requirements.txt
    - agenttalk/service.py
  key_links:
    - "requirements.txt pins exact versions used in Phase 1"
    - "service.py calls setup_logging() as its very first action before any imports of third-party libs"
---

<objective>
Create the project scaffold and validate the Python dependency stack on Windows. This plan establishes the directory layout, pins all Phase 1 dependencies in requirements.txt, and implements the logging and console-suppression infrastructure that every subsequent plan depends on.

Purpose: De-risk the espeakng-loader DLL dependency early. If the Windows DLL fails to load, the error appears in the log file rather than as a silent crash. The scaffold also establishes the APPDATA path constants and file logging setup that are reused in every later module.

Output: requirements.txt with pinned versions; agenttalk/service.py with logging init, APPDATA path constants, sys.excepthook override, and a main() stub that runs under pythonw.exe without a console window.
</objective>

<execution_context>
@C:/Users/omern/.claude/get-shit-done/workflows/execute-plan.md
@C:/Users/omern/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/01-service-skeleton-and-core-audio/01-RESEARCH.md

Key decisions from STATE.md (NON-NEGOTIABLE):
- Python 3.11 required — 3.12+ triggers pystray GIL crash (no fix released)
- kokoro-onnx 0.5.0 is the sole TTS engine for v1
- pystray owns the main thread (Phase 4); uvicorn and TTS run as daemon threads

Key risk from STATE.md:
- espeakng-loader may require VCRUNTIME on a clean Windows machine — this plan validates that by attempting `import kokoro_onnx`
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create requirements.txt with pinned Phase 1 dependencies</name>
  <files>requirements.txt</files>
  <action>
Create `requirements.txt` in the project root with the following exact content. These are the Phase 1 dependencies identified in the research document. Use == for kokoro-onnx and sounddevice (exact versions confirmed from PyPI). Use >= for the others to allow patch updates.

```
kokoro-onnx==0.5.0
sounddevice==0.5.5
fastapi>=0.110
uvicorn>=0.29
psutil>=5.9
```

Do NOT add pystray here — it is a Phase 4 dependency.
  </action>
  <verify>
```bash
cat requirements.txt
python -m pip install -r requirements.txt --dry-run 2>&1 | tail -5
```
The dry-run should show packages would be installed without errors.
  </verify>
  <done>requirements.txt exists at the project root with all five packages. `pip install --dry-run` exits 0.</done>
</task>

<task type="auto">
  <name>Task 2: Validate dependency stack — confirm kokoro_onnx imports cleanly on Windows</name>
  <files></files>
  <action>
Install the dependencies into the active Python 3.11 venv and perform an import validation test. This is the empirical check for the flagged espeakng-loader DLL risk.

Run in sequence:
1. Install: `pip install -r requirements.txt`
2. Validate import: `python -c "import kokoro_onnx; print('kokoro_onnx OK')"`
3. Validate sounddevice: `python -c "import sounddevice; print('sounddevice OK')"`
4. Validate fastapi+uvicorn: `python -c "import fastapi, uvicorn; print('fastapi+uvicorn OK')"`
5. Validate psutil: `python -c "import psutil; print('psutil OK')"`

If step 2 produces a DLL load error (e.g., "DLL load failed" or "VCRUNTIME"), document the exact error message in a comment at the top of requirements.txt and add `espeakng` as a fallback line. The service.py logging setup (Task 3) will capture this at runtime regardless, but document it here so Phase 6 (install script) can include the VCRUNTIME prereq.

If all imports succeed, no action required beyond confirming the output.
  </action>
  <verify>
```bash
python -c "import kokoro_onnx, sounddevice, fastapi, uvicorn, psutil; print('All Phase 1 deps OK')"
```
Should print: `All Phase 1 deps OK`
  </verify>
  <done>All five packages import cleanly in the Python 3.11 venv. Any DLL errors are documented in requirements.txt comments.</done>
</task>

<task type="auto">
  <name>Task 3: Implement service.py scaffold — APPDATA paths, logging, sys.excepthook, main() stub</name>
  <files>agenttalk/service.py</files>
  <action>
Create `agenttalk/service.py` with the following implementation. This is NOT the full service — Plan 02 adds PID lock, Kokoro, health endpoint, and uvicorn. This plan creates the foundation.

Create `agenttalk/` directory if it does not exist. Create `agenttalk/__init__.py` as an empty file.

Implement `agenttalk/service.py` with:

**1. APPDATA path constants (top of file, after stdlib imports only):**
```python
import os
import sys
import logging
import atexit
from pathlib import Path

APPDATA_DIR = Path(os.environ["APPDATA"]) / "AgentTalk"
LOG_FILE    = APPDATA_DIR / "agenttalk.log"
PID_FILE    = APPDATA_DIR / "service.pid"
MODELS_DIR  = APPDATA_DIR / "models"
```

**2. setup_logging() — called before ANY other code in main():**
```python
def setup_logging() -> None:
    APPDATA_DIR.mkdir(parents=True, exist_ok=True)
    logging.basicConfig(
        level=logging.DEBUG,
        format="%(asctime)s [%(levelname)s] %(name)s: %(message)s",
        handlers=[
            logging.FileHandler(LOG_FILE, encoding="utf-8"),
            # No StreamHandler — pythonw.exe discards stdout silently
        ],
    )

    def _log_uncaught(exc_type, exc_value, exc_tb):
        if issubclass(exc_type, KeyboardInterrupt):
            sys.__excepthook__(exc_type, exc_value, exc_tb)
            return
        logging.critical("Uncaught exception", exc_info=(exc_type, exc_value, exc_tb))

    sys.excepthook = _log_uncaught
```

**3. main() stub:**
```python
def main() -> None:
    setup_logging()
    logging.info("=== AgentTalk service starting (scaffold) ===")
    logging.info("APPDATA_DIR: %s", APPDATA_DIR)
    logging.info("LOG_FILE: %s", LOG_FILE)
    logging.info("PID_FILE: %s", PID_FILE)
    logging.info("MODELS_DIR: %s", MODELS_DIR)
    try:
        logging.info("Scaffold startup complete. Plan 02 will add PID lock, Kokoro, and HTTP server.")
        # Keep main thread alive temporarily (Plan 02 will replace this)
        import threading
        threading.Event().wait(timeout=2)
        logging.info("Scaffold exiting cleanly.")
    except Exception:
        logging.exception("Fatal error during scaffold startup")
        sys.exit(1)


if __name__ == "__main__":
    main()
```

**Critical ordering rule:** setup_logging() MUST be the very first call in main(), before any third-party imports. This is enforced by the structure above — all third-party imports (kokoro_onnx, sounddevice, etc.) are deferred to Plan 02.

**Console suppression note:** This file requires NO special code for console suppression. The suppression happens at the interpreter level: the user runs `pythonw.exe agenttalk/service.py`, not `python.exe`. pythonw.exe has no console window by design. Document this in a comment near the top of the file.
  </action>
  <verify>
```bash
# Test that service.py runs and produces log output (not stdout)
python agenttalk/service.py
# Then check the log file was created
python -c "
import os
from pathlib import Path
log = Path(os.environ['APPDATA']) / 'AgentTalk' / 'agenttalk.log'
print('Log exists:', log.exists())
if log.exists():
    content = log.read_text(encoding='utf-8')
    print('Log has content:', len(content) > 0)
    # Show last few lines
    lines = content.strip().splitlines()
    for line in lines[-5:]:
        print(line)
"
```
The log file must exist at `%APPDATA%\AgentTalk\agenttalk.log` and contain startup entries.
  </verify>
  <done>
- `agenttalk/service.py` exists and is importable
- Running `python agenttalk/service.py` exits cleanly (returns 0)
- `%APPDATA%\AgentTalk\agenttalk.log` is created and contains at least one startup log entry
- No output appears on stdout (all logging goes to file only)
  </done>
</task>

</tasks>

<verification>
After all tasks complete:

1. **Dependency validation:**
   ```bash
   python -c "import kokoro_onnx, sounddevice, fastapi, uvicorn, psutil; print('All deps OK')"
   ```
   Must print `All deps OK` without errors.

2. **Service scaffold runs:**
   ```bash
   python agenttalk/service.py
   echo "Exit code: $?"
   ```
   Must exit with code 0.

3. **Log file created:**
   ```bash
   python -c "
   import os; from pathlib import Path
   f = Path(os.environ['APPDATA']) / 'AgentTalk' / 'agenttalk.log'
   print('exists:', f.exists())
   lines = f.read_text(encoding='utf-8').splitlines() if f.exists() else []
   print('lines:', len(lines))
   [print(l) for l in lines]
   "
   ```
   Must show at least 3 log lines including `AgentTalk service starting`.

4. **Project structure:**
   ```bash
   ls agenttalk/
   ```
   Must show `__init__.py` and `service.py`.
</verification>

<success_criteria>
- requirements.txt exists with 5 pinned/bounded packages
- `pip install -r requirements.txt` succeeds on Python 3.11
- `import kokoro_onnx` succeeds (espeakng-loader DLL validated)
- `agenttalk/service.py` exits cleanly and writes to log file
- `%APPDATA%\AgentTalk\agenttalk.log` is created on first run
- Zero output to stdout (pythonw.exe-safe)
</success_criteria>

<output>
After completion, create `.planning/phases/01-service-skeleton-and-core-audio/01-01-SUMMARY.md` with:
- What was implemented
- Result of espeakng-loader DLL validation (success or error + workaround applied)
- Exact Python and package versions confirmed working
- Any deviations from plan
</output>
