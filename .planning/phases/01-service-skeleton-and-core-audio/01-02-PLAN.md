---
phase: 01-service-skeleton-and-core-audio
plan: 02
type: execute
wave: 2
depends_on:
  - "01-01"
files_modified:
  - agenttalk/service.py
autonomous: true
requirements:
  - TTS-01
  - TTS-02
  - TTS-03
  - SVC-05
  - SVC-07

must_haves:
  truths:
    - "Running `pythonw.exe agenttalk/service.py` produces no console window and audio plays through speakers within 10 seconds"
    - "A second launch of the service detects the PID file and exits cleanly without port conflicts or zombie processes"
    - "`%APPDATA%\\AgentTalk\\agenttalk.log` contains startup progress entries including model load and warmup completion"
    - "The `/health` endpoint returns 503 before Kokoro warmup completes and 200 after"
    - "Any startup exception is caught, logged to file, and does not produce a silent crash"
  artifacts:
    - agenttalk/service.py
  key_links:
    - "PID file at `%APPDATA%\\AgentTalk\\service.pid` is written on startup and deleted on exit (atexit)"
    - "FastAPI lifespan sets `is_ready = True` only after kokoro.create() warmup call completes"
    - "uvicorn runs in a BackgroundServer (install_signal_handlers no-op) daemon thread — never on the main thread"
    - "sounddevice uses `WasapiSettings(auto_convert=True)` globally to handle 24000 Hz vs device sample rate"
---

<objective>
Implement the complete Phase 1 service: PID lock, Kokoro TTS load and warmup, sounddevice audio playback, FastAPI /health endpoint, and uvicorn daemon thread. The service synthesizes hardcoded text on startup to prove the full audio pipeline works end-to-end.

Purpose: This is the Phase 1 deliverable. Every later phase builds on this running, logging, audio-capable background process. The success criteria from ROADMAP.md are exactly the acceptance bar for this plan.

Output: A completed `agenttalk/service.py` that satisfies all 7 Phase 1 requirements (TTS-01, TTS-02, TTS-03, SVC-01 already validated by Plan 01, SVC-05, SVC-06 already validated by Plan 01, SVC-07).
</objective>

<execution_context>
@C:/Users/omern/.claude/get-shit-done/workflows/execute-plan.md
@C:/Users/omern/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/01-service-skeleton-and-core-audio/01-RESEARCH.md
@.planning/phases/01-service-skeleton-and-core-audio/01-01-SUMMARY.md

Key decisions from STATE.md (NON-NEGOTIABLE):
- Python 3.11 required
- kokoro-onnx 0.5.0 is the sole TTS engine
- pystray owns the main thread (Phase 4) — for Phase 1, main thread blocks on threading.Event().wait()
- uvicorn MUST run in a daemon thread (never main thread)

Architecture decisions from research (Pattern references in 01-RESEARCH.md):
- Pattern 2: Kokoro load + warmup (eager load before /health returns 200)
- Pattern 3: sounddevice WasapiSettings(auto_convert=True) — set globally at startup
- Pattern 4: PID lock with psutil stale detection + atexit cleanup
- Pattern 6: FastAPI /health with is_ready flag via lifespan
- Pattern 7: BackgroundServer subclass overrides install_signal_handlers() as no-op

Pitfalls to avoid (from 01-RESEARCH.md):
- Do NOT call sd.play() without sd.wait() — audio truncates silently
- Do NOT run uvicorn.run() on the main thread
- Do NOT call logging.basicConfig() after any third-party import
- PID reuse: verify "python" in proc.name().lower() before treating PID as live instance

Model files required (must exist before service runs):
- `%APPDATA%\AgentTalk\models\kokoro-v1.0.onnx`  (~300MB)
- `%APPDATA%\AgentTalk\models\voices-v1.0.bin`
Download from: https://github.com/thewh1teagle/kokoro-onnx/releases/tag/model-files-v1.0

The service must detect missing model files and log a clear error (not crash silently).
</context>

<tasks>

<task type="auto">
  <name>Task 1: Download Kokoro model files to APPDATA</name>
  <files></files>
  <action>
Download the two Kokoro model files to `%APPDATA%\AgentTalk\models\`. These files are required before the service can run. Download them manually or via script.

Create the models directory:
```bash
python -c "
import os
from pathlib import Path
models = Path(os.environ['APPDATA']) / 'AgentTalk' / 'models'
models.mkdir(parents=True, exist_ok=True)
print('Models dir:', models)
"
```

Download the model files from: https://github.com/thewh1teagle/kokoro-onnx/releases/tag/model-files-v1.0
- `kokoro-v1.0.onnx` (~300MB) → save to `%APPDATA%\AgentTalk\models\kokoro-v1.0.onnx`
- `voices-v1.0.bin` → save to `%APPDATA%\AgentTalk\models\voices-v1.0.bin`

You may use Python's urllib or curl to download:
```python
import urllib.request
import os
from pathlib import Path

models = Path(os.environ["APPDATA"]) / "AgentTalk" / "models"
models.mkdir(parents=True, exist_ok=True)

base = "https://github.com/thewh1teagle/kokoro-onnx/releases/download/model-files-v1.0"
for fname in ["kokoro-v1.0.onnx", "voices-v1.0.bin"]:
    dest = models / fname
    if not dest.exists():
        print(f"Downloading {fname}...")
        urllib.request.urlretrieve(f"{base}/{fname}", dest)
        print(f"  -> {dest} ({dest.stat().st_size:,} bytes)")
    else:
        print(f"Already exists: {dest}")
```

Note: Phase 6 will automate this via `agenttalk setup`. For Phase 1, manual download is acceptable.
  </action>
  <verify>
```bash
python -c "
import os
from pathlib import Path
models = Path(os.environ['APPDATA']) / 'AgentTalk' / 'models'
onnx = models / 'kokoro-v1.0.onnx'
bins = models / 'voices-v1.0.bin'
print('onnx exists:', onnx.exists(), '| size:', onnx.stat().st_size if onnx.exists() else 'N/A')
print('bins exists:', bins.exists(), '| size:', bins.stat().st_size if bins.exists() else 'N/A')
"
```
Both files must exist and have non-zero size. `kokoro-v1.0.onnx` should be approximately 290-320MB.
  </verify>
  <done>Both `kokoro-v1.0.onnx` and `voices-v1.0.bin` exist in `%APPDATA%\AgentTalk\models\` with non-zero file sizes.</done>
</task>

<task type="auto">
  <name>Task 2: Implement PID lock — acquire_pid_lock() and release_pid_lock()</name>
  <files>agenttalk/service.py</files>
  <action>
Extend `agenttalk/service.py` (created in Plan 01) by adding the PID lock functions. Insert them after the path constants and before the FastAPI section.

Add to `agenttalk/service.py`:

```python
import psutil  # Add to top-level imports


def acquire_pid_lock() -> None:
    """
    Prevent duplicate service instances.
    - If PID file exists and PID is alive (verified as python process): log and exit.
    - If PID file exists but PID is stale/dead: remove stale file and continue.
    - If no PID file: write current PID and register atexit cleanup.
    """
    if PID_FILE.exists():
        try:
            pid = int(PID_FILE.read_text(encoding="utf-8").strip())
            if psutil.pid_exists(pid):
                try:
                    proc = psutil.Process(pid)
                    if "python" in proc.name().lower():
                        logging.warning(
                            "AgentTalk service already running (PID %d). Exiting.", pid
                        )
                        sys.exit(0)
                except (psutil.NoSuchProcess, psutil.AccessDenied):
                    pass  # PID reuse or access denied — treat as stale
        except (ValueError, OSError):
            pass  # Corrupt PID file — overwrite it

        # Stale PID file — remove and continue startup
        logging.info("Removing stale PID file.")
        PID_FILE.unlink(missing_ok=True)

    PID_FILE.parent.mkdir(parents=True, exist_ok=True)
    PID_FILE.write_text(str(os.getpid()), encoding="utf-8")
    logging.info("PID lock acquired: %s (PID %d)", PID_FILE, os.getpid())
    atexit.register(_release_pid_lock)


def _release_pid_lock() -> None:
    PID_FILE.unlink(missing_ok=True)
    logging.info("PID lock released.")
```

Update `main()` to call `acquire_pid_lock()` immediately after `setup_logging()`:
```python
def main() -> None:
    setup_logging()
    logging.info("=== AgentTalk service starting ===")
    try:
        acquire_pid_lock()
        # ... rest of startup (added in Task 3)
    except Exception:
        logging.exception("Fatal error during startup")
        sys.exit(1)
```

**Critical:** `acquire_pid_lock()` must be called AFTER `setup_logging()` so that the "already running" warning goes to the log file, not stdout.
  </action>
  <verify>
```bash
# Run once — should start (or fail if models not present, which is expected at this stage)
python agenttalk/service.py &
PID=$!
sleep 1

# Check PID file was created
python -c "
import os
from pathlib import Path
pid_file = Path(os.environ['APPDATA']) / 'AgentTalk' / 'service.pid'
print('PID file exists:', pid_file.exists())
if pid_file.exists():
    print('PID file content:', pid_file.read_text().strip())
"

# Kill the first instance
kill $PID 2>/dev/null || true
sleep 1
```
  </verify>
  <done>
- `acquire_pid_lock()` and `_release_pid_lock()` are implemented in service.py
- PID file is written to `%APPDATA%\AgentTalk\service.pid` on startup
- `atexit.register(_release_pid_lock)` is called so PID file is removed on clean exit
  </done>
</task>

<task type="auto">
  <name>Task 3: Implement Kokoro TTS load/warmup, sounddevice playback, FastAPI /health, and uvicorn daemon thread</name>
  <files>agenttalk/service.py</files>
  <action>
Complete `agenttalk/service.py` with the full Phase 1 implementation. Replace the scaffold main() stub with the complete service startup sequence.

**Final complete implementation of `agenttalk/service.py`:**

The file must implement all of the following in a single cohesive module. Write the complete file — do not leave any scaffold stubs from Plan 01 in place.

```python
"""
AgentTalk background service — Phase 1: Service Skeleton and Core Audio.

Launch via: pythonw.exe agenttalk/service.py
Console suppression is handled by the pythonw.exe interpreter itself.
No special subprocess flags are needed for the service process itself.
"""
import os
import sys
import logging
import atexit
import threading
from contextlib import asynccontextmanager
from pathlib import Path

import psutil
import sounddevice as sd
import uvicorn
from fastapi import FastAPI
from fastapi.responses import JSONResponse

# ---------------------------------------------------------------------------
# APPDATA paths
# ---------------------------------------------------------------------------
APPDATA_DIR = Path(os.environ["APPDATA"]) / "AgentTalk"
LOG_FILE    = APPDATA_DIR / "agenttalk.log"
PID_FILE    = APPDATA_DIR / "service.pid"
MODELS_DIR  = APPDATA_DIR / "models"

MODEL_PATH  = MODELS_DIR / "kokoro-v1.0.onnx"
VOICES_PATH = MODELS_DIR / "voices-v1.0.bin"

# ---------------------------------------------------------------------------
# Logging — must be initialised before any other code runs in main()
# ---------------------------------------------------------------------------

def setup_logging() -> None:
    """Configure file-only logging. pythonw.exe discards stdout/stderr."""
    APPDATA_DIR.mkdir(parents=True, exist_ok=True)
    logging.basicConfig(
        level=logging.DEBUG,
        format="%(asctime)s [%(levelname)s] %(name)s: %(message)s",
        handlers=[
            logging.FileHandler(LOG_FILE, encoding="utf-8"),
            # No StreamHandler — pythonw.exe silently discards stdout
        ],
    )

    def _log_uncaught(exc_type, exc_value, exc_tb):
        if issubclass(exc_type, KeyboardInterrupt):
            sys.__excepthook__(exc_type, exc_value, exc_tb)
            return
        logging.critical("Uncaught exception", exc_info=(exc_type, exc_value, exc_tb))

    sys.excepthook = _log_uncaught


# ---------------------------------------------------------------------------
# PID lock — prevents duplicate instances
# ---------------------------------------------------------------------------

def acquire_pid_lock() -> None:
    if PID_FILE.exists():
        try:
            pid = int(PID_FILE.read_text(encoding="utf-8").strip())
            if psutil.pid_exists(pid):
                try:
                    proc = psutil.Process(pid)
                    if "python" in proc.name().lower():
                        logging.warning(
                            "AgentTalk service already running (PID %d). Exiting.", pid
                        )
                        sys.exit(0)
                except (psutil.NoSuchProcess, psutil.AccessDenied):
                    pass  # PID reuse or access denied — treat as stale
        except (ValueError, OSError):
            pass  # Corrupt PID file — overwrite
        logging.info("Removing stale PID file.")
        PID_FILE.unlink(missing_ok=True)

    PID_FILE.parent.mkdir(parents=True, exist_ok=True)
    PID_FILE.write_text(str(os.getpid()), encoding="utf-8")
    logging.info("PID lock acquired: %s (PID %d)", PID_FILE, os.getpid())
    atexit.register(_release_pid_lock)


def _release_pid_lock() -> None:
    PID_FILE.unlink(missing_ok=True)
    logging.info("PID lock released.")


# ---------------------------------------------------------------------------
# TTS engine — kokoro-onnx
# ---------------------------------------------------------------------------

def _load_and_warmup_kokoro():
    """
    Load Kokoro model and perform a warmup synthesis call.
    Warmup forces ONNX JIT compilation, eliminating 3-8s first-request latency.
    Returns the loaded Kokoro instance.
    Raises FileNotFoundError if model files are missing.
    """
    if not MODEL_PATH.exists():
        raise FileNotFoundError(
            f"Kokoro model not found: {MODEL_PATH}\n"
            "Run `agenttalk setup` to download model files."
        )
    if not VOICES_PATH.exists():
        raise FileNotFoundError(
            f"Kokoro voices not found: {VOICES_PATH}\n"
            "Run `agenttalk setup` to download model files."
        )

    from kokoro_onnx import Kokoro  # deferred import — logging is already active

    logging.info("Loading Kokoro model from %s ...", MODEL_PATH)
    kokoro = Kokoro(str(MODEL_PATH), str(VOICES_PATH))
    logging.info("Kokoro model loaded. Running warmup synthesis...")

    _samples, _rate = kokoro.create(
        "Warmup.",
        voice="af_heart",
        speed=1.0,
        lang="en-us",
    )
    logging.info("Warmup synthesis complete (samples=%d, rate=%d).", len(_samples), _rate)
    return kokoro


# ---------------------------------------------------------------------------
# Audio playback — sounddevice + WASAPI
# ---------------------------------------------------------------------------

def _configure_audio() -> None:
    """Set WASAPI auto_convert globally to handle 24000 Hz vs device sample rate."""
    sd.default.extra_settings = sd.WasapiSettings(auto_convert=True)
    logging.info("sounddevice configured with WasapiSettings(auto_convert=True).")


def play_audio(samples, sample_rate: int) -> None:
    """Play numpy audio samples synchronously. sd.wait() is mandatory."""
    sd.play(samples, samplerate=sample_rate)
    sd.wait()  # Block until playback finishes — do NOT omit; audio truncates silently


# ---------------------------------------------------------------------------
# FastAPI — /health endpoint
# ---------------------------------------------------------------------------

is_ready: bool = False
_kokoro_engine = None


@asynccontextmanager
async def _lifespan(app: FastAPI):
    """FastAPI lifespan: load Kokoro before accepting requests; set is_ready after warmup."""
    global is_ready, _kokoro_engine
    try:
        _configure_audio()
        _kokoro_engine = _load_and_warmup_kokoro()
        is_ready = True
        logging.info("Service ready. /health will return 200.")

        # Phase 1 proof: synthesize and play hardcoded audio to confirm full pipeline
        logging.info("Running startup audio proof: synthesizing 'AgentTalk is running.'")
        samples, rate = _kokoro_engine.create(
            "AgentTalk is running.",
            voice="af_heart",
            speed=1.0,
            lang="en-us",
        )
        play_audio(samples, rate)
        logging.info("Startup audio playback complete.")

    except FileNotFoundError:
        logging.error(
            "Model files missing — service will start but /health returns 503 until models are present."
        )
    except Exception:
        logging.exception("Error during Kokoro startup — service degraded; /health returns 503.")

    yield  # Service runs here

    is_ready = False
    logging.info("FastAPI shutdown complete.")


app = FastAPI(lifespan=_lifespan)


@app.get("/health")
def health():
    """Returns 503 while Kokoro is loading; 200 when ready."""
    if not is_ready:
        return JSONResponse({"status": "initializing"}, status_code=503)
    return JSONResponse({"status": "ok"}, status_code=200)


# ---------------------------------------------------------------------------
# Uvicorn daemon thread — Windows-safe (no signal handler)
# ---------------------------------------------------------------------------

class _BackgroundServer(uvicorn.Server):
    def install_signal_handlers(self) -> None:
        pass  # Required: loop.add_signal_handler() raises NotImplementedError on Windows threads


def _start_http_server() -> threading.Thread:
    """Start uvicorn on localhost:5050 in a daemon thread."""
    config = uvicorn.Config(
        app,
        host="127.0.0.1",
        port=5050,
        log_level="warning",
    )
    server = _BackgroundServer(config)
    thread = threading.Thread(target=server.run, daemon=True, name="uvicorn")
    thread.start()
    logging.info("HTTP server thread started (localhost:5050).")
    return thread


# ---------------------------------------------------------------------------
# Main entry point
# ---------------------------------------------------------------------------

def main() -> None:
    setup_logging()  # MUST be first — before any third-party imports or other code
    logging.info("=== AgentTalk service starting ===")
    try:
        acquire_pid_lock()
        _start_http_server()
        logging.info("HTTP daemon thread started. Waiting for lifespan startup...")
        # Phase 1: block main thread indefinitely.
        # Phase 4 replaces this with pystray Icon.run(setup=fn) on the main thread.
        threading.Event().wait()
    except Exception:
        logging.exception("Fatal error during startup")
        sys.exit(1)


if __name__ == "__main__":
    main()
```

**Verify the implementation covers all Phase 1 requirements:**
- TTS-01: `Kokoro(MODEL_PATH, VOICES_PATH)` loads kokoro-onnx 0.5.0 offline
- TTS-02: Warmup `kokoro.create("Warmup.", ...)` call inside lifespan before `is_ready = True`
- TTS-03: `/health` returns 503 until `is_ready = True`; returns 200 after
- SVC-01: pythonw.exe suppresses console (no code change needed — documented in module docstring)
- SVC-05: `acquire_pid_lock()` + `atexit.register(_release_pid_lock)`
- SVC-06: `setup_logging()` with FileHandler only; sys.excepthook override
- SVC-07: `try/except Exception: logging.exception(...)` wraps all of main()
  </action>
  <verify>
```bash
# 1. Start the service in background (using python.exe for test visibility)
python agenttalk/service.py &
SERVICE_PID=$!
sleep 12  # Wait for model load + warmup + audio playback

# 2. Check /health returns 200
python -c "
import urllib.request, json
try:
    resp = urllib.request.urlopen('http://127.0.0.1:5050/health', timeout=5)
    data = json.loads(resp.read())
    print('Health status code:', resp.status)
    print('Health response:', data)
except Exception as e:
    print('Health check failed:', e)
"

# 3. Check log file for expected entries
python -c "
import os
from pathlib import Path
log = Path(os.environ['APPDATA']) / 'AgentTalk' / 'agenttalk.log'
content = log.read_text(encoding='utf-8')
checks = [
    'AgentTalk service starting',
    'PID lock acquired',
    'Loading Kokoro model',
    'Warmup synthesis complete',
    'Service ready',
    'Startup audio playback complete',
]
for check in checks:
    found = check in content
    print(f'  [{\"OK\" if found else \"MISSING\"}] {check}')
"

# 4. Test duplicate instance detection
python agenttalk/service.py
echo "Second launch exit code: $?"

# 5. Stop the service
kill $SERVICE_PID 2>/dev/null || true
sleep 2

# 6. Verify PID file is cleaned up
python -c "
import os
from pathlib import Path
pid = Path(os.environ['APPDATA']) / 'AgentTalk' / 'service.pid'
print('PID file exists after shutdown:', pid.exists())
"
```
  </verify>
  <done>
- `python agenttalk/service.py` starts without errors
- Audio plays through speakers within 10 seconds ("AgentTalk is running.")
- `GET http://127.0.0.1:5050/health` returns HTTP 200 `{"status": "ok"}` after warmup
- Log file contains all 6 expected entries: start, PID lock, model load, warmup, ready, audio complete
- Second launch exits cleanly (logs "already running") without port conflicts
- PID file removed on clean shutdown
  </done>
</task>

</tasks>

<verification>
Full Phase 1 acceptance check — all 5 success criteria from ROADMAP.md:

**Criterion 1:** Running `pythonw.exe agenttalk/service.py` produces no console window and audio plays within 10s
```bash
# Launch via pythonw.exe (Windows only)
start pythonw.exe agenttalk/service.py
# Wait 10 seconds — audio "AgentTalk is running." should play through speakers
# Check log for playback confirmation:
python -c "
import os; from pathlib import Path
log = Path(os.environ['APPDATA']) / 'AgentTalk' / 'agenttalk.log'
content = log.read_text(encoding='utf-8')
print('Audio complete:', 'Startup audio playback complete' in content)
"
```

**Criterion 2:** Second launch detects PID file and exits cleanly
```bash
pythonw.exe agenttalk/service.py  # Second launch
# Must exit immediately; log shows "already running"
python -c "
import os; from pathlib import Path
log = Path(os.environ['APPDATA']) / 'AgentTalk' / 'agenttalk.log'
print('Duplicate detected:', 'already running' in log.read_text(encoding='utf-8'))
"
```

**Criterion 3:** Log contains startup progress entries
```bash
python -c "
import os; from pathlib import Path
log = Path(os.environ['APPDATA']) / 'AgentTalk' / 'agenttalk.log'
content = log.read_text(encoding='utf-8')
required = [
    'AgentTalk service starting',
    'Loading Kokoro model',
    'Warmup synthesis complete',
    'Service ready',
]
all_ok = all(r in content for r in required)
print('Log entries OK:', all_ok)
"
```

**Criterion 4:** /health returns 503 before ready, 200 after
```bash
python -c "
import urllib.request, json, time
# Poll for 200 with timeout
for i in range(15):
    try:
        r = urllib.request.urlopen('http://127.0.0.1:5050/health', timeout=2)
        print(f'Got {r.status} at attempt {i+1}')
        if r.status == 200:
            break
    except Exception as e:
        print(f'Attempt {i+1}: {e}')
    time.sleep(1)
"
```

**Criterion 5:** Startup exception is caught and logged
```bash
# Simulate missing model by temporarily renaming model file
python -c "
import os; from pathlib import Path
m = Path(os.environ['APPDATA']) / 'AgentTalk' / 'models' / 'kokoro-v1.0.onnx'
m2 = m.parent / 'kokoro-v1.0.onnx.bak'
m.rename(m2)
print('Model hidden:', m2.exists())
"
python agenttalk/service.py &
sleep 3
python -c "
import os; from pathlib import Path
# Restore model
m = Path(os.environ['APPDATA']) / 'AgentTalk' / 'models' / 'kokoro-v1.0.onnx'
m2 = m.parent / 'kokoro-v1.0.onnx.bak'
if m2.exists(): m2.rename(m)
# Check log
log = Path(os.environ['APPDATA']) / 'AgentTalk' / 'agenttalk.log'
content = log.read_text(encoding='utf-8')
print('Missing model error logged:', 'Model files missing' in content or 'not found' in content)
"
kill %1 2>/dev/null || true
```
</verification>

<success_criteria>
All 5 Phase 1 ROADMAP success criteria satisfied:
1. `pythonw.exe agenttalk/service.py` → no console window, audio plays within 10s
2. Second launch → detects PID file, exits cleanly, no port conflicts
3. `%APPDATA%\AgentTalk\agenttalk.log` → startup progress including model load and warmup
4. `/health` → 503 during init, 200 after warmup
5. Startup exception → caught, logged, no silent crash

All 7 Phase 1 requirements addressed:
- TTS-01: kokoro-onnx 0.5.0 loaded offline via Kokoro() constructor
- TTS-02: warmup synthesis call inside lifespan before is_ready = True
- TTS-03: /health endpoint 503/200 gate
- SVC-01: pythonw.exe console suppression (interpreter-level, documented)
- SVC-05: PID lock with stale detection + atexit cleanup
- SVC-06: FileHandler-only logging, sys.excepthook override
- SVC-07: try/except wrapping all of main() with logging.exception()
</success_criteria>

<output>
After completion, create `.planning/phases/01-service-skeleton-and-core-audio/01-02-SUMMARY.md` with:
- Confirmation that all 5 ROADMAP success criteria pass
- Actual model load time observed in logs
- Actual sample rate returned by kokoro.create() (confirms WasapiSettings needed)
- Any deviations from the planned implementation
- Phase 1 completion status: COMPLETE if all criteria pass
</output>
