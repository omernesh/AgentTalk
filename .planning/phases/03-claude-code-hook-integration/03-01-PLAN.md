---
phase: 03-claude-code-hook-integration
plan: "01"
type: execute
wave: 1
depends_on: []
files_modified:
  - agenttalk/hooks/__init__.py
  - agenttalk/hooks/stop_hook.py
  - agenttalk/hooks/session_start_hook.py
  - tests/test_hooks.py
autonomous: true
requirements:
  - HOOK-01
  - HOOK-02
  - HOOK-03
  - HOOK-04

must_haves:
  truths:
    - "stop_hook.py reads last_assistant_message from stdin JSON and POSTs it to http://localhost:5050/speak using urllib.request"
    - "stop_hook.py exits immediately when stop_hook_active is true — no POST made"
    - "stop_hook.py exits immediately when last_assistant_message is empty — no POST made"
    - "session_start_hook.py only launches the service when payload source is 'startup'"
    - "session_start_hook.py does not launch the service when the PID file shows a live process"
    - "Both hook scripts read stdin as sys.stdin.buffer.read().decode('utf-8') — CP1252-safe"
    - "All unit tests in tests/test_hooks.py pass with pytest"
  artifacts:
    - agenttalk/hooks/__init__.py
    - agenttalk/hooks/stop_hook.py
    - agenttalk/hooks/session_start_hook.py
    - tests/test_hooks.py
  key_links:
    - "stop_hook.py posts to SERVICE_URL = 'http://localhost:5050/speak' — same endpoint as Phase 2 /speak"
    - "session_start_hook.py reads pythonw path from %APPDATA%\\AgentTalk\\pythonw_path.txt written by setup.py (Plan 02)"
    - "session_start_hook.py reads service path from %APPDATA%\\AgentTalk\\service_path.txt written by setup.py (Plan 02)"
---

<objective>
Create the two Claude Code hook scripts that connect Claude Code's assistant responses to the AgentTalk TTS service, plus their automated unit test suite.

Purpose: These two Python scripts are the integration layer between Claude Code and AgentTalk. stop_hook.py fires after every assistant response and sends the text to the /speak endpoint. session_start_hook.py fires on session startup and auto-launches the service if it is not already running. Both must exit within milliseconds and never block Claude Code's UI.

Output: agenttalk/hooks/stop_hook.py, agenttalk/hooks/session_start_hook.py, tests/test_hooks.py
</objective>

@agenttalk/service.py
@agenttalk/tts_worker.py
@tests/test_preprocessor.py

## Context

Phase 2 delivered a working FastAPI service at localhost:5050 with a POST /speak endpoint. The service PID lock file lives at `%APPDATA%\AgentTalk\service.pid`. The service is started with `pythonw.exe service.py` using DETACHED_PROCESS + CREATE_NEW_PROCESS_GROUP flags.

Phase 3 Plan 02 will create `agenttalk/setup.py` which writes two text files that the session_start_hook reads:
- `%APPDATA%\AgentTalk\pythonw_path.txt` — absolute path to the venv's pythonw.exe
- `%APPDATA%\AgentTalk\service_path.txt` — absolute path to agenttalk/service.py

The hooks MUST NOT import from the agenttalk package (avoids venv import path issues). Use only stdlib.

**Key constraints from research:**
- Stop event does NOT support matchers — fires on every assistant response. Use stop_hook_active guard.
- sys.stdin on Windows defaults to CP1252. MUST use sys.stdin.buffer.read().decode('utf-8').
- Hook commands in settings.json must use absolute paths (setup.py handles this in Plan 02).
- os.kill(pid, 0) raises PermissionError if process exists but is uninterruptible — treat as running.
- urllib.request is stdlib — use it instead of requests to avoid venv dependency in hook scripts.

---

<task>
<name>create-hook-scripts</name>
<type>auto</type>
<files>
  - agenttalk/hooks/__init__.py
  - agenttalk/hooks/stop_hook.py
  - agenttalk/hooks/session_start_hook.py
</files>
<action>
Create the `agenttalk/hooks/` directory with an empty `__init__.py` and two hook scripts.

**agenttalk/hooks/__init__.py** — empty file (marks directory as Python package for IDE support; hooks are run as standalone scripts, not imported).

**agenttalk/hooks/stop_hook.py** — implement exactly as follows:

```python
"""
AgentTalk Stop hook.
Reads last_assistant_message from stdin JSON and POSTs to /speak endpoint.

Requirements: HOOK-01, HOOK-03, HOOK-04
Called by Claude Code after every assistant response.
Registered in ~/.claude/settings.json with async: true by agenttalk setup.
"""
import sys
import json
import urllib.request
import urllib.error

SERVICE_URL = 'http://localhost:5050/speak'
TIMEOUT_SECS = 3  # POST completes in <1s; 3s gives headroom without long block


def main() -> None:
    # HOOK-04: Binary read + explicit UTF-8 decode.
    # sys.stdin on Windows defaults to CP1252 — must use buffer for non-ASCII safety.
    raw = sys.stdin.buffer.read()
    try:
        payload = json.loads(raw.decode('utf-8'))
    except (json.JSONDecodeError, UnicodeDecodeError):
        sys.exit(0)  # Malformed input — silent fail, never block

    # HOOK-01: Guard against infinite loop.
    # Claude Code re-fires Stop hooks when a hook continuation runs.
    # stop_hook_active is True on those re-fires — exit immediately.
    if payload.get('stop_hook_active', False):
        sys.exit(0)

    text = payload.get('last_assistant_message', '').strip()
    if not text:
        sys.exit(0)

    # HOOK-01: POST text to /speak endpoint.
    # 202 = queued, 200 = skipped (alpha filter), 503 = warmup — all acceptable.
    body = json.dumps({'text': text}).encode('utf-8')
    req = urllib.request.Request(
        SERVICE_URL,
        data=body,
        headers={'Content-Type': 'application/json'},
        method='POST',
    )
    try:
        with urllib.request.urlopen(req, timeout=TIMEOUT_SECS) as _:
            pass
    except urllib.error.URLError:
        pass  # Service not running or 503 warmup — silent fail
    except Exception:
        pass  # Any other error — silent fail

    sys.exit(0)  # HOOK-03: Exit immediately; async: true handles non-blocking


if __name__ == '__main__':
    main()
```

**agenttalk/hooks/session_start_hook.py** — implement exactly as follows:

```python
"""
AgentTalk SessionStart hook.
Checks PID file and launches service if not running.

Requirements: HOOK-02, HOOK-03, HOOK-04
Called by Claude Code on new session startup.
Registered in ~/.claude/settings.json with async: true by agenttalk setup.
"""
import sys
import json
import os
import subprocess
from pathlib import Path

APPDATA = Path(os.environ.get('APPDATA', Path.home() / 'AppData' / 'Roaming'))
PID_FILE = APPDATA / 'AgentTalk' / 'service.pid'
# These two files are written by `agenttalk setup` (Plan 02).
# They contain absolute paths so the hook works regardless of cwd.
SERVICE_PATH_FILE = APPDATA / 'AgentTalk' / 'service_path.txt'
PYTHONW_PATH_FILE = APPDATA / 'AgentTalk' / 'pythonw_path.txt'


def _service_is_running() -> bool:
    """Return True if the service PID file points to a live process."""
    if not PID_FILE.exists():
        return False
    try:
        pid_text = PID_FILE.read_text(encoding='utf-8').strip()
        if not pid_text:
            return False
        pid = int(pid_text)
        # os.kill(pid, 0) — signal 0 tests existence without sending a real signal.
        # Raises ProcessLookupError if no such PID exists.
        # Raises PermissionError if process exists but we cannot signal it
        # (treat as running — conservative; PID lock prevents duplicate instances anyway).
        os.kill(pid, 0)
        return True
    except ProcessLookupError:
        return False
    except PermissionError:
        return True  # Process exists — we just don't have permission to signal it
    except Exception:
        return False


def main() -> None:
    # HOOK-04: Binary read + explicit UTF-8 decode — CP1252 safe.
    raw = sys.stdin.buffer.read()
    try:
        payload = json.loads(raw.decode('utf-8'))
    except Exception:
        sys.exit(0)

    # HOOK-02: Only auto-launch on fresh sessions.
    # source values: 'startup' (new session), 'resume', 'clear', 'compact'.
    # Service may already be running for resume/clear — PID check handles that,
    # but filtering here avoids the overhead for non-startup events.
    source = payload.get('source', '')
    if source != 'startup':
        sys.exit(0)

    if _service_is_running():
        sys.exit(0)

    # Launch service as a fully detached subprocess.
    # DETACHED_PROCESS + CREATE_NEW_PROCESS_GROUP fully separates the child from
    # the hook's process tree — essential so Claude Code doesn't own the service process.
    try:
        pythonw = Path(PYTHONW_PATH_FILE.read_text(encoding='utf-8').strip())
        service_py = Path(SERVICE_PATH_FILE.read_text(encoding='utf-8').strip())

        subprocess.Popen(
            [str(pythonw), str(service_py)],
            creationflags=(
                subprocess.DETACHED_PROCESS |
                subprocess.CREATE_NEW_PROCESS_GROUP
            ),
            close_fds=True,
            stdin=subprocess.DEVNULL,
            stdout=subprocess.DEVNULL,
            stderr=subprocess.DEVNULL,
        )
    except Exception:
        pass  # HOOK-03: Never block Claude Code session startup — silent fail

    sys.exit(0)


if __name__ == '__main__':
    main()
```
</action>
<verify>
  <automated>python -c "import ast, sys; ast.parse(open('D:/docker/claudetalk/agenttalk/hooks/stop_hook.py').read()); ast.parse(open('D:/docker/claudetalk/agenttalk/hooks/session_start_hook.py').read()); print('Syntax OK')"</automated>
</verify>
<done>Both hook scripts exist in agenttalk/hooks/, parse without syntax errors, use sys.stdin.buffer.read().decode('utf-8'), exit 0 immediately, and use only stdlib (no agenttalk package imports).</done>
</task>

<task>
<name>write-hook-unit-tests</name>
<type>auto</type>
<files>
  - tests/test_hooks.py
</files>
<action>
Create `tests/test_hooks.py` with pytest unit tests for the hook scripts. Tests import the hooks as modules by calling their `main()` function with mocked stdin.

Use `importlib.util` or direct sys.path manipulation to import stop_hook and session_start_hook from `agenttalk/hooks/`. Use `unittest.mock` to patch sys.stdin.buffer, urllib.request.urlopen, os.kill, and subprocess.Popen.

Implement these five tests:

1. **test_stop_hook_guard_stop_hook_active**: stdin payload has `stop_hook_active: true`. Assert `urlopen` is NOT called. Assert `sys.exit` called with 0.

2. **test_stop_hook_empty_message**: stdin payload has `last_assistant_message: ""`. Assert `urlopen` is NOT called.

3. **test_stop_hook_non_ascii_payload**: stdin payload bytes contain `"last_assistant_message": "café naïve résumé"` encoded as UTF-8. Assert no UnicodeDecodeError is raised and `urlopen` IS called (non-empty message reaches the POST).

4. **test_stop_hook_posts_correct_body**: stdin payload has `last_assistant_message: "Hello world."`. Capture the Request object passed to urlopen. Assert the request body decodes to `{"text": "Hello world."}` and url is `http://localhost:5050/speak`.

5. **test_session_start_hook_no_launch_when_running**: stdin payload has `source: "startup"`. Mock `os.kill` to return None (process exists). Assert `subprocess.Popen` is NOT called.

6. **test_session_start_hook_no_launch_on_resume**: stdin payload has `source: "resume"`. Assert `subprocess.Popen` is NOT called (source filter exits early).

7. **test_session_start_hook_launches_when_not_running**: stdin payload has `source: "startup"`. Mock `os.kill` to raise `ProcessLookupError` (process not found). Mock `PYTHONW_PATH_FILE.read_text` and `SERVICE_PATH_FILE.read_text` to return temp file paths. Assert `subprocess.Popen` IS called with DETACHED_PROCESS creationflags.

**Test structure pattern:**

```python
import json
import os
import subprocess
import sys
from pathlib import Path
from unittest.mock import MagicMock, patch, call
import importlib.util
import pytest

# Helper: load a hook module from its file path
def _load_hook(hook_name: str):
    hooks_dir = Path(__file__).parent.parent / 'agenttalk' / 'hooks'
    spec = importlib.util.spec_from_file_location(hook_name, hooks_dir / f'{hook_name}.py')
    mod = importlib.util.module_from_spec(spec)
    spec.loader.exec_module(mod)
    return mod

# Helper: create a mock stdin buffer for a given payload dict
def _make_stdin(payload: dict) -> MagicMock:
    raw = json.dumps(payload).encode('utf-8')
    m = MagicMock()
    m.read.return_value = raw
    return m
```

Each test patches `sys.stdin` via `with patch.object(sys, 'stdin', ...)` and sets `sys.stdin.buffer = _make_stdin(payload)`. Catch `SystemExit` (since hooks call `sys.exit(0)`) using `pytest.raises(SystemExit)` or wrap in try/except.

The test file must run cleanly with: `python -m pytest tests/test_hooks.py -v`
</action>
<verify>
  <automated>cd /d/docker/claudetalk && python -m pytest tests/test_hooks.py -v 2>&1</automated>
</verify>
<done>All 7 tests in tests/test_hooks.py pass. Tests cover: stop_hook_active guard, empty message, non-ASCII UTF-8, correct POST body, session_start no-launch-when-running, no-launch-on-resume, launches-when-not-running.</done>
</task>

---

## Verification

```
cd /d/docker/claudetalk && python -m pytest tests/test_hooks.py -v
```

Expected: All 7 tests pass, 0 failures.

---

## Success Criteria

- `agenttalk/hooks/stop_hook.py` exists, is valid Python, reads stdin as buffer, guards stop_hook_active, POSTs last_assistant_message to localhost:5050/speak using urllib.request
- `agenttalk/hooks/session_start_hook.py` exists, is valid Python, reads stdin as buffer, only acts on source="startup", checks PID, launches service with DETACHED_PROCESS flags
- Neither hook imports from the agenttalk package (zero non-stdlib dependencies in the scripts themselves)
- `tests/test_hooks.py` exists and all 7 unit tests pass
- HOOK-01, HOOK-02, HOOK-03, HOOK-04 requirements satisfied
