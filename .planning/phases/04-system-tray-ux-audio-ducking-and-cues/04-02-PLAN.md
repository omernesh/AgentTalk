---
phase: 04-system-tray-ux-audio-ducking-and-cues
plan: "02"
type: execute
wave: 2
depends_on:
  - "04-01"
files_modified:
  - agenttalk/service.py
  - agenttalk/tts_worker.py
  - agenttalk/config_loader.py
autonomous: true
requirements:
  - SVC-04
  - TRAY-03
  - CUE-01
  - CUE-02
  - CUE-03
  - CUE-04

must_haves:
  truths:
    - "service.py main() calls icon.run(setup=_setup) on the main thread — threading.Event().wait() is removed"
    - "The _setup(icon) callback sets icon.visible = True, then starts the HTTP server daemon thread, then starts the TTS worker daemon thread"
    - "The on_quit callback passed to build_tray_icon calls os._exit(0) to terminate the process after icon.stop()"
    - "tts_worker.py STATE dict has new keys: speaking (bool), pre_cue_path (str|None), post_cue_path (str|None)"
    - "The TTS worker calls play_cue(STATE['pre_cue_path']) before ducking and synthesis"
    - "The TTS worker calls duck() before the synthesis loop and unduck() after the synthesis loop"
    - "The TTS worker calls play_cue(STATE['post_cue_path']) after unduck() and after all sentences finish"
    - "The TTS worker sets STATE['speaking'] = True before synthesis and STATE['speaking'] = False in the finally block"
    - "The TTS worker sets icon.icon = create_image_speaking() when speaking starts and icon.icon = create_image_idle() in the finally block"
    - "play_cue(path) is a no-op when path is None or empty string — no winsound call made"
    - "play_cue(path) uses winsound.SND_FILENAME (synchronous) — NOT SND_ASYNC"
    - "An atexit handler calls ducker.unduck() so volumes are restored even if the service crashes mid-speech"
    - "agenttalk/config_loader.py exports load_config() returning a dict read from %APPDATA%/AgentTalk/config.json; missing file returns {}; JSON parse errors are logged and return {}"
    - "service.py calls load_config() at startup and writes pre_cue_path and post_cue_path from the config dict into STATE before icon.run() is called — so cue paths are user-configurable via config.json (CUE-04)"
  artifacts:
    - path: "agenttalk/service.py"
      provides: "main() uses icon.run(setup=_setup); _setup starts HTTP and TTS threads with icon reference; on_quit cleans up"
      contains: "icon.run"
    - path: "agenttalk/tts_worker.py"
      provides: "Extended _tts_worker with cue playback, ducking, speaking state, and icon image swapping"
      contains: "pre_cue_path"
    - path: "agenttalk/config_loader.py"
      provides: "load_config() — reads %APPDATA%/AgentTalk/config.json, returns dict, safe on missing/corrupt file"
      exports: ["load_config"]
  key_links:
    - from: "agenttalk/service.py"
      to: "agenttalk/tray.py"
      via: "from agenttalk.tray import build_tray_icon, create_image_idle, create_image_speaking"
      pattern: "from agenttalk\\.tray import"
    - from: "agenttalk/tts_worker.py"
      to: "agenttalk/audio_duck.py"
      via: "from agenttalk.audio_duck import AudioDucker"
      pattern: "from agenttalk\\.audio_duck import"
    - from: "agenttalk/tts_worker.py"
      to: "agenttalk/tray.py"
      via: "from agenttalk.tray import create_image_idle, create_image_speaking"
      pattern: "from agenttalk\\.tray import"
    - from: "agenttalk/service.py"
      to: "agenttalk/config_loader.py"
      via: "from agenttalk.config_loader import load_config"
      pattern: "from agenttalk\\.config_loader import"
---

<objective>
Wire the tray icon and audio ducking/cues into the existing service.py and tts_worker.py.

Purpose: Plan 04-01 built the new modules in isolation. This plan integrates them: service.py's main() surrenders the main thread to pystray (SVC-04), the TTS worker gains audio ducking, pre/post cues, and speaking state signalling to the tray icon (CUE-01–04, TRAY-03).

Output: Modified agenttalk/service.py (icon.run replaces threading.Event), modified agenttalk/tts_worker.py (ducking + cues + icon swap).
</objective>

<execution_context>
@C:/Users/omern/.claude/get-shit-done/workflows/execute-plan.md
@C:/Users/omern/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/04-system-tray-ux-audio-ducking-and-cues/04-RESEARCH.md
@.planning/phases/04-system-tray-ux-audio-ducking-and-cues/04-01-SUMMARY.md

<interfaces>
<!-- Contracts established by Plan 04-01 and Phase 1-2 code. No codebase exploration needed. -->

From agenttalk/tray.py (created in Plan 04-01):
```python
def build_tray_icon(state: dict, on_quit: callable = None) -> pystray.Icon:
    """Returns a pystray.Icon. Does NOT call icon.run() or set icon.visible."""
    ...

def create_image_idle(size: int = 64) -> Image.Image: ...
def create_image_speaking(size: int = 64) -> Image.Image: ...
```

From agenttalk/audio_duck.py (created in Plan 04-01):
```python
class AudioDucker:
    def duck(self) -> None: ...    # Ducks all non-AgentTalk sessions to 50%
    def unduck(self) -> None: ...  # Restores saved volumes
    @property
    def is_ducked(self) -> bool: ...
```

From agenttalk/service.py (Phase 1-2 — existing):
```python
# Current main() — MUST BE REPLACED:
def main() -> None:
    setup_logging()
    logging.info("=== AgentTalk service starting ===")
    try:
        acquire_pid_lock()
        _start_http_server()
        logging.info("HTTP daemon thread started. Waiting for lifespan startup...")
        # Phase 1: block main thread indefinitely.
        # Phase 4 replaces this with pystray Icon.run(setup=fn) on the main thread.
        threading.Event().wait()
    except Exception:
        logging.exception("Fatal error during startup")
        sys.exit(1)
```

From agenttalk/tts_worker.py (Phase 2 — existing):
```python
# Current STATE dict:
STATE: dict = {
    "volume": 1.0,
    "speed": 1.0,
    "voice": "af_heart",
    "muted": False,
}

# Current start_tts_worker signature:
def start_tts_worker(kokoro_engine) -> threading.Thread: ...
```

From 04-RESEARCH.md (Pattern 1 — pystray Main Thread Ownership):
```python
def _setup(icon):
    icon.visible = True          # REQUIRED: icon is hidden until explicitly shown
    _start_http_server()         # starts uvicorn daemon thread
    start_tts_worker(_kokoro_engine, icon=icon)  # passes icon ref to worker

icon = build_tray_icon(state=STATE, on_quit=_on_quit)
icon.run(setup=_setup)           # blocks main thread — replaces threading.Event().wait()
```

CRITICAL — icon.visible = True MUST be inside the setup callback, NOT before icon.run().
The visible property can only be set while the icon is running (research pitfall #1).

CRITICAL — on_quit must call os._exit(0) (not sys.exit) after icon.stop():
- `icon.stop()` terminates the Win32 message loop but does NOT kill daemon threads.
- sys.exit() raises SystemExit which daemon threads can swallow.
- os._exit(0) immediately terminates the entire process. This is correct for a tray app.
- The atexit handler (unduck) runs before os._exit(0) only if registered via atexit.register().
  Register the atexit handler in main() BEFORE icon.run().

From 04-RESEARCH.md (Pattern 5 — Pre/Post Audio Cues):
```python
import winsound

def play_cue(path: str | None) -> None:
    """Play a WAV cue synchronously. No-op if path is None or empty."""
    if not path:
        return
    try:
        winsound.PlaySound(path, winsound.SND_FILENAME)
    except RuntimeError:
        logging.warning("Audio cue failed to play: %s", path)
```

CRITICAL — use winsound.SND_FILENAME (synchronous). Do NOT use SND_ASYNC.
The cue must complete BEFORE TTS begins. Async overlap ruins the timing (research pitfall).

From 04-RESEARCH.md (Updated _tts_worker Integration Sketch):
```python
while True:
    sentences: list[str] = TTS_QUEUE.get()
    try:
        if STATE["muted"]:
            TTS_QUEUE.task_done()
            continue

        # Notify tray: speaking started
        if _icon_ref:
            _icon_ref.icon = create_image_speaking()
        STATE["speaking"] = True

        # Pre-cue (before ducking — cue is part of AgentTalk, not ducked)
        play_cue(STATE.get("pre_cue_path"))

        # Duck other audio
        _ducker.duck()

        for sentence in sentences:
            if not sentence.strip():
                continue
            samples, rate = kokoro_engine.create(
                sentence, voice=STATE["voice"],
                speed=STATE["speed"], lang="en-us",
            )
            scaled = samples * STATE["volume"]
            if STATE["volume"] > 1.0:
                scaled = np.clip(scaled, -1.0, 1.0)
            sd.play(scaled, samplerate=rate)
            sd.wait()

        # Un-duck
        _ducker.unduck()

        # Post-cue
        play_cue(STATE.get("post_cue_path"))

    except Exception:
        logging.exception("TTS worker error — skipping batch.")
        _ducker.unduck()  # ensure unduck even on error
    finally:
        STATE["speaking"] = False
        if _icon_ref:
            _icon_ref.icon = create_image_idle()
        TTS_QUEUE.task_done()
```

NOTE on muted early exit: The existing worker checks STATE["muted"] per-sentence.
Replace the per-sentence check with a batch-level check at the top of the try block.
If muted, skip the entire batch (no ducking, no cues, no synthesis). Call task_done() explicitly.
The `continue` pattern does NOT call task_done() automatically — use try/finally or call explicitly.

NOTE on _icon_ref and _ducker module-level state:
- Declare `_icon_ref = None` and `_ducker: AudioDucker = AudioDucker()` at module level.
- `start_tts_worker(kokoro_engine, icon=None)` accepts the icon reference and stores it
  in the module-level `_icon_ref`.
- The atexit handler in service.py calls `_ducker.unduck()` directly via:
  `from agenttalk.tts_worker import _ducker` in service.py, OR pass the ducker reference
  through a cleanup callback. SIMPLEST approach: expose `_ducker` as a module-level
  name and import it in service.py for the atexit handler.

From agenttalk/config_loader.py (new — created in Task 3):
```python
import json, os, logging, pathlib

def _config_path() -> pathlib.Path:
    appdata = os.environ.get("APPDATA", pathlib.Path.home())
    return pathlib.Path(appdata) / "AgentTalk" / "config.json"

def load_config() -> dict:
    """
    Read %APPDATA%/AgentTalk/config.json and return its contents as a dict.
    Returns {} if the file does not exist or contains invalid JSON.
    Never raises — config loading is best-effort.
    """
    path = _config_path()
    if not path.exists():
        return {}
    try:
        return json.loads(path.read_text(encoding="utf-8"))
    except Exception:
        logging.warning("Failed to load config from %s", path, exc_info=True)
        return {}
```

This module is NEW — create it from scratch in Task 3. It is imported by service.py to seed STATE
with cue paths before icon.run() starts. This satisfies CUE-04 ("configurable via config.json").
The slash command and tray-menu setters for cue paths are delivered in Phase 5 (CMD/CFG requirements).
</interfaces>
</context>

<tasks>

<task type="auto">
  <name>Task 1: Update service.py — replace threading.Event().wait() with icon.run(setup=_setup)</name>
  <files>agenttalk/service.py</files>
  <action>
    Modify `agenttalk/service.py`. DO NOT rewrite the file — make targeted modifications only.

    **Step 1: Add new imports** at the top of service.py (after existing imports):
    ```python
    import pystray
    from agenttalk.tray import build_tray_icon, create_image_idle, create_image_speaking
    from agenttalk.tts_worker import _ducker
    ```

    **Step 2: Replace the main() function body** — find and replace the existing main() function.

    Current main() to replace:
    ```python
    def main() -> None:
        setup_logging()  # MUST be first — before any third-party imports or other code
        logging.info("=== AgentTalk service starting ===")
        try:
            acquire_pid_lock()
            _start_http_server()
            logging.info("HTTP daemon thread started. Waiting for lifespan startup...")
            # Phase 1: block main thread indefinitely.
            # Phase 4 replaces this with pystray Icon.run(setup=fn) on the main thread.
            threading.Event().wait()
        except Exception:
            logging.exception("Fatal error during startup")
            sys.exit(1)
    ```

    Replace with:
    ```python
    def main() -> None:
        setup_logging()  # MUST be first — before any third-party imports or other code
        logging.info("=== AgentTalk service starting ===")
        try:
            acquire_pid_lock()

            # Register atexit: unduck any ducked sessions on abnormal exit.
            # This covers crashes and SIGTERM — prevents Spotify/browser stuck at 50%.
            atexit.register(_ducker.unduck)

            def _on_quit() -> None:
                """Called by tray Quit menu item before icon.stop()."""
                logging.info("Tray Quit selected — shutting down.")
                _ducker.unduck()  # Restore any ducked sessions immediately
                # os._exit(0) is called after icon.stop() returns in the _quit handler.
                # We use os._exit here so daemon threads are terminated cleanly.
                os._exit(0)

            # Build tray icon (does NOT run — just constructs the pystray.Icon object).
            # STATE is imported from tts_worker; tray menu reads muted and voice from it.
            icon = build_tray_icon(state=STATE, on_quit=_on_quit)

            def _setup(icon: pystray.Icon) -> None:
                """
                Called by pystray once the Win32 message loop is running.
                MUST set icon.visible = True here (not before icon.run()).
                Start daemon threads here so the icon is ready before HTTP/TTS begin.
                """
                icon.visible = True  # REQUIRED — icon starts hidden by default (pystray pitfall #1)
                _start_http_server()
                start_tts_worker(_kokoro_engine, icon=icon)
                logging.info("Service setup complete — tray icon visible, HTTP and TTS threads running.")

            # SVC-04: pystray Icon.run() takes the main thread (Win32 message loop).
            # This replaces threading.Event().wait() from Phase 1.
            # _setup fires once the icon is running; it starts the daemon threads.
            logging.info("Starting pystray tray icon on main thread.")
            icon.run(setup=_setup)

        except Exception:
            logging.exception("Fatal error during startup")
            sys.exit(1)
    ```

    IMPORTANT — _lifespan timing: The _lifespan coroutine (FastAPI lifespan) runs inside uvicorn's
    asyncio loop, which is started by _start_http_server(). The lifespan sets `is_ready = True`
    and calls `start_tts_worker(_kokoro_engine)` — but in the new flow, start_tts_worker is called
    from _setup() with the icon reference. To avoid double-starting the TTS worker:

    - Remove the `start_tts_worker(_kokoro_engine)` call from `_lifespan()` in service.py.
    - The _setup callback now owns TTS worker startup.
    - The _lifespan still sets `is_ready = True` after Kokoro loads — that is unchanged.
    - The icon reference flows: main() → _setup(icon) → start_tts_worker(_kokoro_engine, icon=icon)

    Find and remove this block from _lifespan():
    ```python
            # Start TTS worker daemon thread — must be started after Kokoro is loaded.
            # The worker thread consumes from TTS_QUEUE and calls kokoro_engine.create().
            start_tts_worker(_kokoro_engine)
            logging.info("TTS worker started.")
    ```

    NOTE: The `_kokoro_engine` global is set by `_lifespan` when Kokoro loads. The _setup
    callback runs AFTER _start_http_server() is called, but _lifespan runs asynchronously
    inside uvicorn. There is a startup race: _setup fires, calls start_tts_worker(_kokoro_engine),
    but _kokoro_engine may still be None if Kokoro hasn't finished loading.

    To handle this race: `start_tts_worker` should be called from _lifespan AFTER Kokoro loads,
    passing the icon reference. Update the approach:

    - Keep `start_tts_worker` call in `_lifespan` but pass the icon reference.
    - Add a module-level `_tray_icon = None` in service.py.
    - In _setup, set `_tray_icon = icon` then start HTTP. Do NOT call start_tts_worker from _setup.
    - In _lifespan, after `is_ready = True`, call `start_tts_worker(_kokoro_engine, icon=_tray_icon)`.

    Revised flow:
    ```python
    # module level (add after is_ready and _kokoro_engine):
    _tray_icon = None

    # In _setup callback:
    def _setup(icon: pystray.Icon) -> None:
        global _tray_icon
        icon.visible = True
        _tray_icon = icon
        _start_http_server()
        logging.info("HTTP server started. Waiting for Kokoro model load...")

    # In _lifespan, replace the removed start_tts_worker block with:
    start_tts_worker(_kokoro_engine, icon=_tray_icon)
    logging.info("TTS worker started with icon reference.")
    ```

    This ensures _kokoro_engine is loaded before the TTS worker starts, and the icon reference
    is captured before lifespan runs (icon.run(setup=_setup) → _setup fires → _tray_icon set
    → uvicorn starts → _lifespan runs → start_tts_worker gets both kokoro and icon).
  </action>
  <verify>
    **Static import check:**
    ```bash
    cd /d/docker/claudetalk && python -c "import agenttalk.service; print('service.py imports OK')"
    ```
    Prints "service.py imports OK" without error.

    **Confirm threading.Event().wait() is gone:**
    ```bash
    grep -n "threading.Event" /d/docker/claudetalk/agenttalk/service.py
    ```
    No output (the line must be removed).

    **Confirm icon.run is present:**
    ```bash
    grep -n "icon.run" /d/docker/claudetalk/agenttalk/service.py
    ```
    Shows `icon.run(setup=_setup)` line.

    **Confirm start_tts_worker is called from _lifespan with icon argument:**
    ```bash
    grep -n "start_tts_worker" /d/docker/claudetalk/agenttalk/service.py
    ```
    Shows the call in _lifespan context (not in _setup).
  </verify>
  <done>
    service.py imports cleanly. threading.Event().wait() is removed. icon.run(setup=_setup) is present in main(). _setup sets icon.visible=True and starts HTTP server. _lifespan calls start_tts_worker(_kokoro_engine, icon=_tray_icon) after Kokoro loads. _ducker.unduck() is registered with atexit. _on_quit calls os._exit(0).
  </done>
</task>

<task type="auto">
  <name>Task 2: Update tts_worker.py — add ducking, cues, speaking state, and icon image swap</name>
  <files>agenttalk/tts_worker.py</files>
  <action>
    Modify `agenttalk/tts_worker.py`. DO NOT rewrite the file — make targeted additions.

    **Step 1: Add new imports** at the top (after existing imports):
    ```python
    import winsound
    from agenttalk.audio_duck import AudioDucker
    from agenttalk.tray import create_image_idle, create_image_speaking
    ```

    **Step 2: Add new module-level state** after the existing STATE dict:
    ```python
    # Phase 4 additions to STATE:
    STATE["speaking"] = False          # True while TTS is synthesizing/playing (TRAY-03)
    STATE["pre_cue_path"] = None       # Path to WAV file played before each utterance (CUE-01, CUE-03)
    STATE["post_cue_path"] = None      # Path to WAV file played after each utterance (CUE-02, CUE-03)

    # Module-level AudioDucker instance — shared between worker and atexit handler.
    # Exported so service.py can register atexit(_ducker.unduck).
    _ducker: AudioDucker = AudioDucker()

    # Icon reference — set by start_tts_worker() when icon is available.
    _icon_ref = None
    ```

    **Step 3: Update start_tts_worker() signature** to accept the icon reference:
    ```python
    def start_tts_worker(kokoro_engine, icon=None) -> threading.Thread:
        """
        Start the TTS daemon thread.

        Args:
            kokoro_engine: Loaded Kokoro instance from kokoro_onnx.
            icon: Optional pystray.Icon reference for speaking state indicator (TRAY-03).
                  If None, icon image swapping is skipped (safe for testing without tray).

        Returns:
            The started daemon Thread.
        """
        global _icon_ref
        _icon_ref = icon
        t = threading.Thread(
            target=_tts_worker,
            args=(kokoro_engine,),
            daemon=True,
            name="tts-worker",
        )
        t.start()
        logging.info("TTS worker daemon thread started (icon=%s).", "yes" if icon else "none")
        return t
    ```

    **Step 4: Add play_cue() helper function** (place before _tts_worker):
    ```python
    def play_cue(path: str | None) -> None:
        """
        Play a WAV audio cue synchronously. No-op if path is None or empty.

        Uses winsound.SND_FILENAME (blocking) — the cue must finish before TTS begins.
        DO NOT use SND_ASYNC; async playback overlaps with speech synthesis.

        CUE-01, CUE-02, CUE-03: Optional pre/post cue playback.
        """
        if not path:
            return
        try:
            winsound.PlaySound(path, winsound.SND_FILENAME)
        except Exception:
            logging.warning("Audio cue failed to play: %s", path, exc_info=True)
    ```

    **Step 5: Replace _tts_worker() body** with the updated version that includes
    ducking, cues, speaking state, and icon image swapping.

    Replace the current _tts_worker function with:
    ```python
    def _tts_worker(kokoro_engine) -> None:
        """
        Blocking TTS synthesis loop — runs in daemon thread.

        Phase 4 additions: audio ducking (AUDIO-07), pre/post cues (CUE-01–04),
        speaking state flag (TRAY-03), icon image swapping (TRAY-03).

        Sequence per utterance batch:
          1. Check muted — skip entire batch if True
          2. Set speaking=True, swap icon to speaking image
          3. Play pre-cue (synchronous WAV, if configured)
          4. Duck other audio sessions
          5. Synthesize and play each sentence
          6. Unduck audio sessions
          7. Play post-cue (synchronous WAV, if configured)
          8. finally: set speaking=False, swap icon to idle, call task_done()
        """
        logging.info("TTS worker thread running.")
        while True:
            sentences: list[str] = TTS_QUEUE.get()
            try:
                if STATE["muted"]:
                    logging.debug("TTS: muted — skipping batch of %d sentences.", len(sentences))
                    continue

                # TRAY-03: Notify tray icon that TTS is speaking
                STATE["speaking"] = True
                if _icon_ref is not None:
                    try:
                        _icon_ref.icon = create_image_speaking()
                    except Exception:
                        logging.debug("Icon swap to speaking failed (non-fatal).", exc_info=True)

                # CUE-01: Play pre-speech cue (synchronous — must finish before synthesis)
                play_cue(STATE.get("pre_cue_path"))

                # AUDIO-07: Duck other audio sessions
                _ducker.duck()

                for sentence in sentences:
                    if not sentence.strip():
                        continue

                    logging.debug("TTS: synthesizing %r", sentence[:60])
                    samples, rate = kokoro_engine.create(
                        sentence,
                        voice=STATE["voice"],
                        speed=STATE["speed"],
                        lang="en-us",
                    )

                    # Apply volume scaling; clip to [-1.0, 1.0] if >1.0
                    scaled = samples * STATE["volume"]
                    if STATE["volume"] > 1.0:
                        scaled = np.clip(scaled, -1.0, 1.0)

                    sd.play(scaled, samplerate=rate)
                    sd.wait()

                # AUDIO-07: Restore ducked sessions after all sentences finish
                _ducker.unduck()

                # CUE-02: Play post-speech cue
                play_cue(STATE.get("post_cue_path"))

            except Exception:
                logging.exception("TTS worker error — skipping batch.")
                # Ensure unduck on error path (pitfall #4 — volumes stuck at 50% after crash)
                if _ducker.is_ducked:
                    try:
                        _ducker.unduck()
                    except Exception:
                        logging.warning("Unduck on error path also failed.", exc_info=True)
            finally:
                # TRAY-03: Always restore idle icon and clear speaking flag
                STATE["speaking"] = False
                if _icon_ref is not None:
                    try:
                        _icon_ref.icon = create_image_idle()
                    except Exception:
                        logging.debug("Icon swap to idle failed (non-fatal).", exc_info=True)
                TTS_QUEUE.task_done()
    ```

    NOTE: The `continue` in the muted branch must still call task_done(). The current structure
    uses `try...finally` which guarantees task_done() via the finally block. The `continue`
    inside a try/finally DOES execute the finally block — this is correct Python behavior.
  </action>
  <verify>
    **Static import check:**
    ```bash
    cd /d/docker/claudetalk && python -c "
    import agenttalk.tts_worker as w
    print('TTS_QUEUE maxsize:', w.TTS_QUEUE.maxsize)
    print('STATE keys:', sorted(w.STATE.keys()))
    print('_ducker type:', type(w._ducker).__name__)
    print('_icon_ref:', w._icon_ref)
    print('tts_worker.py OK')
    "
    ```
    Expected:
    - `TTS_QUEUE maxsize: 3`
    - `STATE keys: ['muted', 'post_cue_path', 'pre_cue_path', 'speaking', 'speed', 'voice', 'volume']`
    - `_ducker type: AudioDucker`
    - `_icon_ref: None`
    - `tts_worker.py OK`

    **Confirm winsound import and play_cue function:**
    ```bash
    cd /d/docker/claudetalk && python -c "
    from agenttalk.tts_worker import play_cue
    play_cue(None)       # Must be silent no-op
    play_cue('')         # Must be silent no-op
    print('play_cue no-op OK')
    "
    ```
    Prints "play_cue no-op OK" with no errors, no audio.

    **Confirm pre/post cue state keys are present:**
    ```bash
    cd /d/docker/claudetalk && python -c "
    from agenttalk.tts_worker import STATE
    assert 'pre_cue_path' in STATE
    assert 'post_cue_path' in STATE
    assert 'speaking' in STATE
    assert STATE['pre_cue_path'] is None
    assert STATE['post_cue_path'] is None
    assert STATE['speaking'] is False
    print('STATE cue keys OK')
    "
    ```
    Prints "STATE cue keys OK".
  </verify>
  <done>
    tts_worker.py imports cleanly. STATE has 7 keys including speaking, pre_cue_path, post_cue_path. _ducker is an AudioDucker instance. _icon_ref is None. play_cue(None) and play_cue('') are no-ops. start_tts_worker accepts icon= kwarg. _tts_worker() has duck/unduck/cue calls in correct sequence.
  </done>
</task>

<task type="auto">
  <name>Task 3: Create agenttalk/config_loader.py and seed STATE cue paths from config.json at startup</name>
  <files>agenttalk/config_loader.py, agenttalk/service.py</files>
  <action>
    This task satisfies CUE-04: "Audio cue paths are configurable via config.json." Phase 5 will add the
    slash command and tray-menu setters. Phase 4 delivers the config.json read side.

    **Step 1: Create agenttalk/config_loader.py.**

    Create a new file with exactly this content:

    ```python
    """
    config_loader.py — Read %APPDATA%/AgentTalk/config.json.

    Provides load_config() which returns the persisted settings dict.
    Returns {} if the file is absent or malformed — never raises.

    Phase 4 consumers: service.py reads pre_cue_path and post_cue_path at startup.
    Phase 5 will add write support (save_config) for slash command and tray setters.
    """
    import json
    import logging
    import os
    import pathlib


    def _config_path() -> pathlib.Path:
        """Return the platform path to config.json."""
        appdata = os.environ.get("APPDATA", str(pathlib.Path.home()))
        return pathlib.Path(appdata) / "AgentTalk" / "config.json"


    def load_config() -> dict:
        """
        Read %APPDATA%/AgentTalk/config.json and return its contents as a dict.

        Returns {} if:
        - The file does not exist (first run, no config yet).
        - The file contains invalid JSON (corrupted config).

        Never raises — config loading is best-effort. Logs a warning on parse error.
        """
        path = _config_path()
        if not path.exists():
            logging.debug("No config file found at %s — using defaults.", path)
            return {}
        try:
            text = path.read_text(encoding="utf-8")
            cfg = json.loads(text)
            if not isinstance(cfg, dict):
                logging.warning("config.json does not contain a JSON object — ignoring.")
                return {}
            logging.debug("Loaded config from %s: %s", path, list(cfg.keys()))
            return cfg
        except Exception:
            logging.warning("Failed to load config from %s — using defaults.", path, exc_info=True)
            return {}
    ```

    **Step 2: Update service.py to seed STATE cue paths from config.json at startup.**

    Add the import at the top of service.py (after existing imports):
    ```python
    from agenttalk.config_loader import load_config
    ```

    Add a startup config-read block in main(), AFTER `acquire_pid_lock()` and BEFORE
    `atexit.register(_ducker.unduck)`. Insert these lines:

    ```python
    # CUE-04: Load persisted config and seed cue paths into STATE before the tray starts.
    # Phase 5 will add write support; Phase 4 reads only.
    _cfg = load_config()
    if _cfg.get("pre_cue_path"):
        STATE["pre_cue_path"] = _cfg["pre_cue_path"]
        logging.info("Config: pre_cue_path = %s", STATE["pre_cue_path"])
    if _cfg.get("post_cue_path"):
        STATE["post_cue_path"] = _cfg["post_cue_path"]
        logging.info("Config: post_cue_path = %s", STATE["post_cue_path"])
    ```

    NOTE: STATE is already imported from tts_worker in service.py (it is used by build_tray_icon).
    If STATE is not yet imported, add `from agenttalk.tts_worker import STATE, _ducker` alongside
    the existing `from agenttalk.tts_worker import _ducker` import.

    IMPORTANT: Place the config-read block BEFORE icon.run() is called so the cue paths are in
    STATE before the tray icon is built and before any TTS request is served.
  </action>
  <verify>
    **Import check — config_loader:**
    ```bash
    cd /d/docker/claudetalk && python -c "
    from agenttalk.config_loader import load_config
    cfg = load_config()
    print('load_config returned:', type(cfg).__name__)
    assert isinstance(cfg, dict), 'must return a dict'
    print('config_loader.py OK')
    "
    ```
    Expected output:
    - `load_config returned: dict`
    - `config_loader.py OK`

    **Verify config.json seeding with a real file:**
    ```bash
    cd /d/docker/claudetalk && python -c "
    import os, json, pathlib, tempfile
    # Patch _config_path to a temp file
    from agenttalk import config_loader
    tmp = pathlib.Path(tempfile.mktemp(suffix='.json'))
    tmp.write_text(json.dumps({'pre_cue_path': 'C:/test/bell.wav', 'post_cue_path': ''}))
    _orig = config_loader._config_path
    config_loader._config_path = lambda: tmp
    cfg = config_loader.load_config()
    assert cfg.get('pre_cue_path') == 'C:/test/bell.wav', f'got {cfg}'
    assert 'post_cue_path' in cfg
    config_loader._config_path = _orig
    tmp.unlink()
    print('Config read test OK')
    "
    ```
    Prints "Config read test OK".

    **Verify service.py imports config_loader:**
    ```bash
    grep -n "load_config\|config_loader" /d/docker/claudetalk/agenttalk/service.py
    ```
    Shows the import and the _cfg seeding lines.

    **Verify STATE is seeded before icon.run (ordering check):**
    ```bash
    grep -n "load_config\|pre_cue_path\|icon.run" /d/docker/claudetalk/agenttalk/service.py
    ```
    The load_config line must appear at a lower line number than the icon.run line.
  </verify>
  <done>
    agenttalk/config_loader.py exists and exports load_config(). load_config() returns {} when no
    config file exists and returns the dict when the file is valid JSON. service.py imports load_config,
    reads the config at startup, and seeds STATE["pre_cue_path"] and STATE["post_cue_path"] from it
    before icon.run() is called. CUE-04 config.json read path is implemented.
  </done>
</task>

</tasks>

<verification>
Run after all three tasks complete:

**1. Full import chain — all Phase 4 modules link correctly:**
```bash
cd /d/docker/claudetalk && python -c "
import agenttalk.service
import agenttalk.tts_worker
import agenttalk.tray
import agenttalk.audio_duck
import agenttalk.config_loader
print('All Phase 4 imports OK')
"
```
Prints "All Phase 4 imports OK".

**1b. config_loader returns dict and seeds correctly (CUE-04):**
```bash
cd /d/docker/claudetalk && python -c "
from agenttalk.config_loader import load_config
cfg = load_config()
assert isinstance(cfg, dict)
print('config_loader OK, keys:', list(cfg.keys()))
"
```
Prints without error.

**2. threading.Event().wait() removed from service.py (SVC-04):**
```bash
grep -n "threading.Event" /d/docker/claudetalk/agenttalk/service.py
```
No output.

**3. icon.run(setup=_setup) present in service.py (SVC-04):**
```bash
grep -n "icon.run" /d/docker/claudetalk/agenttalk/service.py
```
Shows line with `icon.run(setup=_setup)`.

**4. TTS worker STATE has all Phase 4 keys:**
```bash
cd /d/docker/claudetalk && python -c "
from agenttalk.tts_worker import STATE, _ducker, play_cue
assert 'speaking' in STATE and 'pre_cue_path' in STATE and 'post_cue_path' in STATE
assert STATE['pre_cue_path'] is None and STATE['post_cue_path'] is None
play_cue(None); play_cue('')
print('Worker state and play_cue OK')
"
```
Prints "Worker state and play_cue OK".

**5. atexit unduck registered (pitfall #4 — volumes stuck after crash):**
```bash
grep -n "atexit.register" /d/docker/claudetalk/agenttalk/service.py
```
Shows `atexit.register(_ducker.unduck)` line.

**6. Existing test suite still passes (regression):**
```bash
cd /d/docker/claudetalk && python -m pytest tests/ -v
```
All pre-existing tests pass (preprocessor + hooks).

**7. Live tray integration test (manual — run service and verify tray icon appears):**
```bash
cd /d/docker/claudetalk && python agenttalk/service.py
```
- AgentTalk icon appears in Windows system tray notification area (TRAY-01)
- Right-click shows: Mute, Voice submenu, Active voice info, separator, Quit (TRAY-02, TRAY-04, TRAY-05, TRAY-06)
- Send a speak request while watching tray: icon changes color during speech (TRAY-03)
  ```bash
  curl -s -X POST http://127.0.0.1:5050/speak -H "Content-Type: application/json" -d '{"text":"Testing audio ducking and tray icon speaking indicator."}'
  ```
- If Spotify or browser audio is playing, volume drops during TTS and restores after (AUDIO-07)
- Quit from tray menu terminates the process cleanly
</verification>

<success_criteria>
- service.py main() uses icon.run(setup=_setup) — threading.Event().wait() is removed (SVC-04)
- _setup(icon) sets icon.visible=True first, then starts HTTP server (TRAY-01)
- _lifespan calls start_tts_worker(_kokoro_engine, icon=_tray_icon) after Kokoro loads (TRAY-03)
- on_quit calls _ducker.unduck() then os._exit(0) (TRAY-05, AUDIO-07 cleanup)
- atexit.register(_ducker.unduck) registered in main() (AUDIO-07 crash safety)
- tts_worker.py STATE has speaking, pre_cue_path, post_cue_path keys (CUE-01, CUE-02, CUE-03, CUE-04)
- tts_worker._ducker is module-level AudioDucker instance, exported for atexit
- play_cue(None) and play_cue('') are silent no-ops — no winsound call (CUE-03)
- play_cue(path) uses winsound.SND_FILENAME — synchronous, not SND_ASYNC (CUE-01, CUE-02)
- _tts_worker sequence: mute check → speaking=True → icon swap → pre-cue → duck → synthesize → unduck → post-cue → finally: speaking=False, icon swap, task_done
- On error path: unduck() called if is_ducked, task_done() always called via finally (AUDIO-07 safety)
- Icon swaps to speaking image when synthesis starts, idle image in finally block (TRAY-03)
- agenttalk/config_loader.py exists and exports load_config() returning a dict (CUE-04)
- load_config() returns {} on missing or malformed config.json — never raises (CUE-04)
- service.py calls load_config() at startup and seeds STATE["pre_cue_path"] and STATE["post_cue_path"] from the returned dict before icon.run() (CUE-04 — config.json read path)
- All Phase 1-3 tests pass after changes (regression)
- Live test: tray icon visible, right-click menu correct, speaking indicator works, Quit terminates service
</success_criteria>

<output>
After completion, create `.planning/phases/04-system-tray-ux-audio-ducking-and-cues/04-02-SUMMARY.md`
</output>
